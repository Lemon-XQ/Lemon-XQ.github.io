<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2018%2F10%2F31%2F%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91Ubuntu16.04%2Bcuda8.0%2Bcudnn6.0%2BPython3.6%2BAnaconda%2Btensorflow-gpu1.3%E9%85%8D%E7%BD%AE%EF%BC%88%E8%B8%A9%E5%9D%91%E8%AE%B0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[##前言最近换了带GPU的新电脑，终于有机会体验深度学习，然而搭个环境搭得我呕心沥血，各种莫名其妙的ERROR，差点就从入门到放弃……好不容易终于成功了，记录一下QAQ ##安装显卡驱动 检查自己的显卡支不支持GPU加速计算，也就是CUDA功能，这个可以在CUDA官网上找到； 在Nvidia官网查找自己显卡对应的显卡驱动型号，如下图，我的是390.59； 终端输入如下语句安装相应型号的显卡驱动（注意改成你自己的型号）；12345sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updatesudo apt-get install nvidia-390sudo apt-get install mesa-common-devsudo apt-get install freeglut3-dev 4.安装完后sudo reboot一下，运行nvidia-smi命令，若打印出相关信息则说明显卡驱动安装成功。 ##安装CUDA8.0 同样去NVIDIA官网下载对应平台的CUDA Toolkit，注意选择runfile，不要选deb！！！（一开始用的deb后面到tensorflow引入时报各种错，改成runfile就好了= =）； 下好后终端运行sudo sh cuda_8.0.61_375.26_linux.run，注意在询问是否安装Graphics Driver时一定要选no！！！因为前面我们已经安装过显卡驱动了，这里再安装一次的话可能会有问题（比如我的是390它会给我装384….然后电脑就经常黑屏，只能强制重启TAT，找了好久才发现是这个问题…除了这个其他一律默认yes 在/etc/profile中添加相关环境变量1234sudo vim /etc/profile#在末尾添加两行export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$LD_LIBRARY_PATH 4.执行source /etc/profile使环境变量生效 ctrl+Alt+T打开新终端，输入nvcc -V，如果输出显卡信息则说明安装成功。6.为了避免后续安装出现问题，这里有必要测试一下能不能跑通sample123cd /usr/local/cuda-8.0/samples/1_Utilities/deviceQuerysudo make./deviceQuery 如果能打印出显卡信息则可以进行下一步，否则请Google解决。 ##安装cuDNN6.0 官网给出了详细的安装文档，需要注意的是cuDNN一定要和cuda版本配套，如cuda8.0和cudnn6.0对应； 这里分享一个好心人的网盘链接https://pan.baidu.com/s/1hs23HrA，免去注册填问卷的步骤23333； 安装好后进行解压，拷贝至cuda目录1234tar xvzf cudnn-8.0-Linux-x64-v5.1.tgz sudo cp cuda/include/cudnn.h /usr/local/cuda-8.0/include sudo cp cuda/lib64/libcudnn.so* /usr/local/cuda-8.0/lib64 sudo chmod a+r /usr/local/cuda-8.0/include/cudnn.h /usr/local/cuda-8.0/lib64/libcudnn.so* ##安装Anaconda Anaconda官网上有两个版本，分别对应Python3.6和Python2.7，这里我选择的是3.6的； 下载好后执行bash Anaconda3-5.1.0-Linux-x86_64.sh进行安装，一直按yes或者回车就对了；##使用Anaconda创建tensorflow环境 执行conda create -n tensorflow Python=3.6，然后Anaconda会下载所有的依赖包，包括pip，numpy这些，这个过程比较久； 执行conda activate tensorflow激活环境； 安装1.3版本的tensorflow，注意是gpu版本，而且Python是3.612pip install –ignore-installed –upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.3.0rc0-cp36-cp36m-linux_x86_64.whl 4.测试GPU版tensorflow是否安装成功；123python&gt;&gt;&gt;import tensorflow as tf&gt;&gt;&gt;sess=tf.Session() 如果打印出GPU信息，说明安装成功啦！！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记 2018.9.8 PAT甲级+题解]]></title>
      <url>%2F2018%2F09%2F25%2F%E8%AE%B0-2018-9-8-PAT%E7%94%B2%E7%BA%A7-%E9%A2%98%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[写在前面 前两天考完就想写了，结果一直拖到现在orz……8月中旬的时候无意中看到PAT这个东东，因为刚好在准备保研，要复习机试的东西，就报了这个，虽然之前有接触过一点点ACM，不过个人对这种数据结构算法一直都不是特别擅长，准备了半个多月，每天都在刷题总结复习中度过，直到考完才感觉松了一口气，放一下分数和排名吧=w=（虽然感觉可以考的更好，不过也还算满意啦） 分数：91/100 排名：78/2237 感受这次PAT考试有几个特点： 放宽了时间限制，也就是说完全暴力也可以AC…… 第一道题逻辑难，据说是顶级30分题？太打击了，反正我一开始就没思路（当时以为不能暴力…） STL、DFS太重要了…… 考试一共是3个小时，考前几次模拟我都是第一道题15min左右，第二、三道30min左右，最后一道视情况（30min-1h），不过这次考试显然有点特殊，第一道狼人杀就把我打击到了，10几分钟都没有思路，只能先放着，跳到第二道，二、三都不是很难，1h左右跑通两道，提交的时候有一道错了一个3分的测试点，没管，直接看最后一道= =（考完发现那个错误其实很低级。。） 最后一道是LCA，考试前做了一道LCA的，是针对BST的，BST的LCA很容易找，但是考试要求求的是普通二叉树的LCA，一开始一直想的是各种先后序层序遍历序列找，试了快一个小时都没成功，最后换成DFS，10minAC…… 做完三道只剩半个小时了，回去看那道狼人杀，试了10min连样例都跑不通QAQ内心一直想放弃，突然灵光一现（？）改了一种半暴力的方法，居然跑通样例了，这时只剩5min了，赶紧提交，居然只错了一个测试点，不过剩下的时间也不够了，就这样结束了我的第一次（也是最后一次）PAT考试@_@ 一些建议 考纲里的每个点都要掌握！数据结构主要是队列、栈、链表、树、图，算法主要是最短路、DFS、BFS那些 考前一个月每天都要保持题量和题感，最好是把题库里的都做一遍！ 每次遇到不会的题不要一下子就去网上找题解，一般2h想不出的我才会去看看别人的思路，然后看看自己是哪里想错了，进行改进，不要直接copy代码！ 确定考场后要第一时间确定考场提供的IDE是哪些，确保有自己熟悉的IDE，没有的话最好提前一个月更换IDE进行练习（比如我之前一直是用C-Free的，邮件问了考场老师才知道考场没有C-Free，只有Dev-C++…），不然就会像考场里很多同学一样，花了不少时间在熟悉IDE上…… 题解说了这么多，放一下本次考试题解吧（对应PAT题库1148-1151），均是可以AC的 第一题狼人杀，题意就是给出N个人的叙述，N个人中有两个狼人（1个撒谎1个不撒谎），而所有人中撒谎的只有两个，也就是说最终有一个撒谎的狼人和一个撒谎的村民，因此可以直接暴力枚举所有狼人组合，对每一个狼人组合，统计撒谎的狼人数和撒谎的村民数，如果都为1说明找到答案，如果枚举所有组合后都找不到答案，说明无解。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N; cin&gt;&gt;N; int arr[N+1]; for(int i=1;i&lt;=N;i++) cin&gt;&gt;arr[i]; bool flag=false; int a,b; // 列举每一种狼人组合 for(int i=1;i&lt;=N;i++)&#123; for(int j=i+1;j&lt;=N;j++)&#123; int lie_wolf=0,lie_human=0; for(int k=1;k&lt;=N;k++)&#123;// 判断该狼人组合下是否满足1个撒谎的狼人+1个撒谎的村民 if(k==i || k==j)&#123;// 狼人 if(arr[k]&gt;0 &amp;&amp; arr[k]==i || arr[k]==j) lie_wolf++; else if(arr[k]&lt;0 &amp;&amp; abs(arr[k])!=i &amp;&amp; abs(arr[k])!=j) lie_wolf++; &#125;else&#123;// 村民 if(arr[k]&gt;0 &amp;&amp; arr[k]==i || arr[k]==j) lie_human++; else if(arr[k]&lt;0 &amp;&amp; abs(arr[k])!=i &amp;&amp; abs(arr[k])!=j) lie_human++; &#125; &#125; if(lie_wolf==1 &amp;&amp; lie_human==1)&#123; a=i; b=j; flag=true; break; &#125; &#125; if(flag) break; &#125; if(flag) cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl; else cout&lt;&lt;"No Solution"&lt;&lt;endl; return 0;&#125; 2.第二题题意是给出一些危险物配对，比如A和B不能一起出现，B和C不能一起出现（但A和C可以一起出现，所以不是并查集问题），求所给序列中有没有危险物。思路也很简单，直接暴力遍历序列，找有没有危险匹配即可。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int MAXV=100001;vector&lt;int&gt; m[MAXV];// 存储每个物品对应的危险物品列表int main()&#123; int N,M; cin&gt;&gt;N&gt;&gt;M; for(int i=0;i&lt;N;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; m[a].push_back(b); m[b].push_back(a); &#125; for(int i=0;i&lt;M;i++)&#123; int K; cin&gt;&gt;K; int arr[K]; bool flag=true; for(int j=0;j&lt;K;j++) cin&gt;&gt;arr[j]; for(int j=0;j&lt;K-1;j++)&#123;// 从前到后暴力比较 for(int k=j+1;k&lt;K;k++)&#123; if(find(m[arr[j]].begin(),m[arr[j]].end(),arr[k])!=m[arr[j]].end())&#123; flag=false; break; &#125; &#125; if(!flag)break; &#125; if(flag) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125; 3.第三题是售货商问题。不过这道题不需要去求解，只需要判断所给序列是不是满足条件即可，思路也很简单，先判断路径是否连通，不连通就输出“Not a TS cycle”，连通的话再判断序列是否包含了全部结点且首尾结点相同，是则为TS cycle或TS simple cycle，二者可以通过序列长度进行判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;const int INF=0x3fffffff;const int MAXV=201;int G[MAXV][MAXV];int main()&#123; int N,M,K; cin&gt;&gt;N&gt;&gt;M; fill(G[0],G[0]+MAXV*MAXV,-1); for(int i=0;i&lt;M;i++)&#123; int a,b,dis; cin&gt;&gt;a&gt;&gt;b&gt;&gt;dis; G[a][b]=G[b][a]=dis; &#125; cin&gt;&gt;K; int ans_index,ans_len=INF; for(int i=1;i&lt;=K;i++)&#123; int n; cin&gt;&gt;n; int path[n],len=0; bool flag=true; set&lt;int&gt; s; for(int j=0;j&lt;n;j++)&#123; cin&gt;&gt;path[j]; s.insert(path[j]); &#125; for(int j=0;j&lt;n-1;j++)&#123; if(G[path[j]][path[j+1]]==-1)&#123; flag=false;// 说明所给路径不连通 break; &#125;else len+=G[path[j]][path[j+1]];// 路径总长度 &#125; if(flag)&#123; if(s.size()!=N || path[0]!=path[n-1])&#123; printf("Path %d: %d (Not a TS cycle)\n",i,len); &#125;else&#123; if(len&lt;ans_len)&#123;// TS cycle 记录最短路径长度及路径编号 ans_len=len; ans_index=i; &#125; if(s.size()==n-1) printf("Path %d: %d (TS simple cycle)\n",i,len); else printf("Path %d: %d (TS cycle)\n",i,len); &#125; &#125; else printf("Path %d: NA (Not a TS cycle)\n",i); &#125; printf("Shortest Dist(%d) = %d",ans_index,ans_len); return 0;&#125; 4.最后一题是LCA问题。要求找二叉树中任两个结点的最小公共祖先结点。我的思路是先建树，然后对两个结点进行dfs，求出根节点到这两个结点的路径，对两条路径从头到尾比较，出现的第一个不同的结点则退出循环，该结点的前一个结点就是它们的LCA（比如：3结点的路径是1-&gt;5-&gt;3，4结点的路径是1-&gt;5-&gt;4，则它们的LCA为5），如果没有出现不同的结点说明二者是包含关系，根据两条路径长度可以判断谁是祖先。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int MAXV=10001;struct node&#123; node* lchild; node* rchild; int data; node()&#123; lchild=rchild=NULL; &#125;&#125;;int in[MAXV],pre[MAXV];map&lt;int,int&gt; m;node* create(int preL,int preR,int inL,int inR)&#123; if(preL&gt;preR) return NULL; node* root=new node; root-&gt;data=pre[preL]; int i; for(i=inL;i&lt;=inR;i++)&#123; if(in[i]==pre[preL]) break; &#125; int len=i-inL; root-&gt;lchild=create(preL+1,preL+len,inL,i-1); root-&gt;rchild=create(preL+len+1,preR,i+1,inR); return root;&#125;vector&lt;int&gt; path,ans;bool flag=false;void dfs(node* root,int v)&#123; if(root==NULL) return; if(root-&gt;data==v)&#123; flag=true; path.push_back(root-&gt;data); ans=path; path.pop_back(); return; &#125;else&#123; path.push_back(root-&gt;data); dfs(root-&gt;lchild,v); if(flag) return; path.pop_back(); path.push_back(root-&gt;data); dfs(root-&gt;rchild,v); if(flag) return; path.pop_back(); &#125;&#125;int main()&#123; int M,N; cin&gt;&gt;M&gt;&gt;N; for(int i=0;i&lt;N;i++)&#123; cin&gt;&gt;in[i]; m[in[i]]=i;// 记录某个结点是否出现过 &#125; for(int i=0;i&lt;N;i++) cin&gt;&gt;pre[i]; node* root=create(0,N-1,0,N-1);// 根据先序中序序列建树 for(int i=0;i&lt;M;i++)&#123; int u,v; cin&gt;&gt;u&gt;&gt;v; if(m.count(u)==0 &amp;&amp; m.count(v)==0) printf("ERROR: %d and %d are not found.\n",u,v); else if(m.count(u)==0) printf("ERROR: %d is not found.\n",u); else if(m.count(v)==0) printf("ERROR: %d is not found.\n",v); else&#123; // dfs分别遍历u,v结点，得到两条路径 vector&lt;int&gt; pu,pv; path.clear(); flag=false; dfs(root,u); pu=ans; path.clear(); flag=false; dfs(root,v); pv=ans; // 找两条路径第一个不同的结点 int j; for(j=0;j&lt;min(pu.size(),pv.size());j++)&#123; if(pu[j]!=pv[j]) break; &#125; if(j!=min(pu.size(),pv.size())) printf("LCA of %d and %d is %d.\n",u,v,pu[j-1]); else if(pu.size()&lt;pv.size()) printf("%d is an ancestor of %d.\n",u,v); else printf("%d is an ancestor of %d.\n",v,u); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图像边缘检测及提取方法总结（含Matlab代码）]]></title>
      <url>%2F2018%2F03%2F24%2F%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E5%90%ABMatlab%E4%BB%A3%E7%A0%81%EF%BC%89%2F</url>
      <content type="text"><![CDATA[写在前面 呼~最近开始入坑图像+机器学习了，学习的过程中遇到了不少不懂的东西，好在自学能力还可以（自恋中= =），所以断断续续也算学会了一些东西~因为这段时间一直在做边缘检测和提取的工作，所以本篇就总结一下一些常见的边缘检测方法，篇幅较长，可按点查看~ 名词解释 图像处理中经常用到一些名词，以下列举一些： 1. 滤波 所谓滤波就是对每个像素点及其邻域点的灰度值按照一定的参数规则进行加权平均，这样可以有效滤去理想图像中叠加的高频噪声。常用的滤波有线性滤波、中值滤波、均值滤波、双边滤波、高斯滤波等。滤波有抑制噪声的作用，但这会使得图像边缘模糊。 2. 直方图 在图像处理中，经常用到直方图，如颜色直方图、灰度直方图等。直方图可以直观展现数据分布情况，如灰度直方图中，横坐标为各个灰度范围，纵坐标为处在相应范围的像素数。图像直方图不关心像素所处的空间位置，因此不受图像旋转和平移变化的影响，可以作为图像的特征。 3. 上采样 上采样即放大图像（或称图像插值（interpolating））,从而使图像可以显示在更高分辨率的显示设备上。注意对图像的缩放操作通常会影响图像的质量。上采样几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。 4. 下采样 下采样即缩小图像（或称为降采样（downsampled）），其主要目的有两个：1、使得图像符合显示区域的大小；2、生成对应图像的缩略图。 下采样原理：对于一幅图像I尺寸为M*N，对其进行s倍下采样，即得到(M/s)*(N/s)尺寸的分辨率图像，当然s应该是M和N的公约数才行，如果考虑的是矩阵形式的图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点的值就是窗口内所有像素的均值 Canny算子1.原理 canny算子与LoG算子类似，属于先平滑后求导数的方法，原理可分成下面4个部分： 1.1 高斯滤波 在所有滤波方法中，需要考虑的最重要的一点是如何平衡去噪与边缘检测精确之间的矛盾。实际工程经验表明，高斯函数确定的核可以提供较好的折衷方案。 高斯滤波实现方法有两种：离散化窗口滑动卷积、傅里叶变换。因前者比较常用，故下面只介绍前者。 离散化窗口滑动卷积主要利用高斯核实现，即一个奇数大小的高斯模板。常用的高斯核模板有3*3 和 5*5两种 其中的参数通过高斯函数计算，x^2+y^2表示像素点和中心像素点的距离，sigma表示标准差。 注： sigma如果选的过大，会加深滤波程度，从而导致图像边缘模糊，不利于下一步的边缘检测，如果过小，则滤波效果不佳 计算高斯模板参数时，需要归一化处理，对于归一化的原因，有一种解释是：归一化之后，通过卷积计算出来的模板中心像素被限制到了0-255的灰度区间中。假若某一邻域内所有像素的灰度值为255，利用该模板进行卷积之后，求得的模板中心像素灰度值仍然为255；假若计算出来的高斯模板参数之和小于1，那么通过该模板进行卷积之后，模板中心像素的灰度值将小于255，偏离了实际的灰度值，产生了误差。 1.2 求梯度幅值和梯度方向 canny算子使用的卷积算子如下： 梯度幅值及梯度方向的计算如下，其中P表示x方向一阶偏导数矩阵，Q表示y方向一阶偏导数矩阵，M表示梯度幅值，θ表示梯度方向 1.3 非极大值抑制 在上面求出的梯度幅值矩阵中，值越大的元素代表其梯度越大，但它不一定是边缘像素，因此需要进行非极大值抑制，也就是寻找像素点局部最大值，将非极大值点所对应的灰度值置为0，这样可以剔除掉一大部分非边缘的点。 如上图，判定C点是否为8邻域内最大梯度值点，只需要判断C是否比C的梯度方向上dTmp1和dTmp2点大，是则保留，不是则将C点灰度值置0。而dTmp1和dTmp2的梯度值可以通过插值得到。 1.4 双阈值法闭合边缘 上面得到的边缘有些为假边缘，且有边缘断裂的问题，如果根据高阈值得到一个边缘图像，这样一个图像含有很少的假边缘，但是由于阈值较高，产生的图像边缘可能不闭合，因此还要采用一个低阈值，当到达轮廓的端点时，在断点的8邻域点中寻找满足低阈值的点，再根据此点收集新的边缘，直到整个图像边缘闭合。 2.实现2.1 原始图像灰度化12img = imread('lena.jpg');img = rgb2gray(img); 2.2 调用matlab内置函数12img_edge = edge(img,'canny');figure;imshow(img_edge);title('canny'); Roberts、Sobel、Prewitt算子图像的灰度值梯度可以用一阶偏导的有限差分近似计算，常用梯度算子有： Roberts算子 梯度幅值为： matlab中可直接调用：edge(img,&#39;roberts&#39;) Sobel算子 梯度幅值为： matlab中可直接调用：edge(img,&#39;sobel&#39;) Prewitt算子 matlab中可直接调用：edge(img,&#39;prewitt&#39;) 双边滤波（Bilateral Filters）1. 原理 传统滤波方法多多少少会有模糊边缘的缺点，而双边滤波作为一种非线性滤波器，具有在降噪平滑的同时，保持边缘的效果。该特性主要是通过在卷积的过程中组合空域(space)函数和值域(range)核函数来实现的，空域指的是像素的欧氏距离，值域指的是像素范围域中的辐射差异（如卷积核中像素与中心像素之间相似程度、颜色强度，深度距离等）。典型的核函数为高斯分布函数，如下所示： 其中，权重系数w(i,j,k,l)取决于空域核和值域核的乘积： 在图像的平坦区域，像素值变化很小，对应的像素值域权重接近于1，此时空域权重起主要作用，相当于进行高斯模糊；在图像的边缘区域，像素值变化很大，像素值域权重变大，从而保持了边缘的信息。 2. 实现 上述方法的时间复杂度是O(σd^2)，非常耗时。论文《Fast O(1) bilateral ﬁltering using trigonometric range kernels》，提出了用Raised cosines函数来逼近高斯值域函数，并利用一些特性把值域函数分解为一些列函数的叠加，从而实现函数的加速，而论文” A fast approximation of the bilateral filter using a signal processing approach”则提出了一种使用信号处理的方法，主要是在原有域上添加了信号强度这一维，构成了高维空间，在高维空间中进行下采样，下面的代码是作者团队编写的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113% 双边滤波函数function output = fBilateralFilter_ReviseVer( data, edge, edgeMin, edgeMax, sigmaSpatial, sigmaRange,samplingSpatial, samplingRange )if ~exist( 'edge', 'var' ) edge = data;elseif isempty( edge ) edge = data;endinputHeight = size( data, 1 );inputWidth = size( data, 2 );if ~exist( 'edgeMin', 'var' ) edgeMin = min( edge( : ) );% warning( 'edgeMin not set! Defaulting to: %f\n', edgeMin );endif ~exist( 'edgeMax', 'var' ) edgeMax = max( edge( : ) );% warning( 'edgeMax not set! Defaulting to: %f\n', edgeMax );endedgeDelta = edgeMax - edgeMin;% hl- span of range% hl- assign scale parameters in both spatial and range domainif ~exist( 'sigmaSpatial', 'var' ) sigmaSpatial = min( inputWidth, inputHeight ) / 16; fprintf( 'Using default sigmaSpatial of: %f\n', sigmaSpatial );endif ~exist( 'sigmaRange', 'var' ) sigmaRange = 0.1 * edgeDelta; fprintf( 'Using default sigmaRange of: %f\n', sigmaRange );endif ~exist( 'samplingSpatial', 'var' ) samplingSpatial = sigmaSpatial;endif ~exist( 'samplingRange', 'var' ) samplingRange = sigmaRange;endif size( data ) ~= size( edge ) error( 'data and edge must be of the same size' );end% parametersderivedSigmaSpatial = sigmaSpatial / samplingSpatial; derivedSigmaRange = sigmaRange / samplingRange;paddingXY = floor( 2 * derivedSigmaSpatial ) + 1;paddingZ = floor( 2 * derivedSigmaRange ) + 1;% allocate 3D griddownsampledWidth = floor( ( inputWidth - 1 ) / samplingSpatial ) + 1 + 2 * paddingXY; % paddingXY - 控制延拓范围downsampledHeight = floor( ( inputHeight - 1 ) / samplingSpatial ) + 1 + 2 * paddingXY;downsampledDepth = floor( edgeDelta / samplingRange ) + 1 + 2 * paddingZ;gridData = zeros( downsampledHeight, downsampledWidth, downsampledDepth );gridWeights = zeros( downsampledHeight, downsampledWidth, downsampledDepth );% compute downsampled indices[ jj, ii ] = meshgrid( 0 : inputWidth - 1, 0 : inputHeight - 1 ); % hl- create the coordinats of xy-plane; jj - y coordinates of all pixels, ii - x coordinates of all pixels%Compute the downsampled coordinatesdi = round( ii / samplingSpatial ) + paddingXY + 1; % round: Round to nearest integer四舍五入dj = round( jj / samplingSpatial ) + paddingXY + 1;dz = round( ( edge - edgeMin ) / samplingRange ) + paddingZ + 1;% hl - average sampling (box sampling)for k = 1 : numel( dz ) % numel: Number of elements in an array dataZ = data( k ); % traverses the image column wise, same as di( k ) if ~isnan(dataZ), dik = di( k ); %取出坐标 djk = dj( k ); dzk = dz( k ); gridData( dik, djk, dzk ) = gridData( dik, djk, dzk ) + dataZ; gridWeights( dik, djk, dzk ) = gridWeights( dik, djk, dzk ) + 1; endend% make gaussian kernelkernelWidth = 2 * derivedSigmaSpatial + 1;kernelHeight = kernelWidth;kernelDepth = 2 * derivedSigmaRange + 1;halfKernelWidth = floor( kernelWidth / 2 );halfKernelHeight = floor( kernelHeight / 2 );halfKernelDepth = floor( kernelDepth / 2 );[gridX, gridY, gridZ] = meshgrid( 0 : kernelWidth - 1, 0 : kernelHeight - 1, 0 : kernelDepth - 1 );gridX = gridX - halfKernelWidth;gridY = gridY - halfKernelHeight;gridZ = gridZ - halfKernelDepth;gridRSquared = ( gridX .* gridX + gridY .* gridY ) / ( derivedSigmaSpatial * derivedSigmaSpatial ) + ( gridZ .* gridZ ) / ( derivedSigmaRange * derivedSigmaRange );kernel = exp( -0.5 * gridRSquared );% convolveblurredGridData = convn( gridData, kernel, 'same' );blurredGridWeights = convn( gridWeights, kernel, 'same' );% divideblurredGridWeights( blurredGridWeights == 0 ) = -2; % avoid divide by 0, won't read there anyway normalizedBlurredGrid = blurredGridData ./ blurredGridWeights;normalizedBlurredGrid( blurredGridWeights &lt; -1 ) = 0; % put 0s where it's undefined% upsample[ jj, ii ] = meshgrid( 0 : inputWidth - 1, 0 : inputHeight - 1 ); % meshgrid does x, then y, so output arguments need to be reversed% no roundingdi = ( ii / samplingSpatial ) + paddingXY + 1;dj = ( jj / samplingSpatial ) + paddingXY + 1;dz = ( edge - edgeMin ) / samplingRange + paddingZ + 1;output = interpn( normalizedBlurredGrid, di, dj, dz ); % N-D data interpolationend Hessian特征1. 原理 Hessian矩阵本质是是一个多元函数的二阶偏导数矩阵，描述了函数的局部曲率。关于Hessian矩阵的由来及详细推导证明见参考资料3，这里直接介绍如何得到Hessian矩阵： 高斯函数 求二阶偏导 对原图进行卷积 构成Hessian矩阵 2. 实现12345678910111213141516171819202122% 提取Hessian特征值function [hessianValue,Ixx,Ixy,Iyy] = edge_hessian(img) [m n]=size(img); w=4; sigma=1.2; [x y]=meshgrid(-w:w,-w:w); % 高斯函数对应的二阶偏导 Dxx = 1/(-2*pi*sigma^4)*(1-x.^2/sigma^2)*exp(-(x.^2+x.^2)/(2*sigma^2)); Dyy = 1/(-2*pi*sigma^4)*(1-y.^2/sigma^2)*exp(-(x.^2+y.^2)/(2*sigma^2)); Dxy = 1/(2*pi*sigma^6)*(x.*y)*exp(-(x.^2+y.^2)/(2*sigma^2)); Ixx=imfilter(img,Dxx,'replicate'); Iyy=imfilter(img,Dyy,'replicate'); Ixy=imfilter(img,Dxy,'replicate'); hessianValue=[]; for i=1:m for j=1:n hessianValue(i,j) = Ixx(i,j)*Iyy(i,j) - Ixy(i,j)*Ixy(i,j); end endend Haar特征1. 原理 Haar特征是一种反映图像的灰度变化的，像素分模块求差值的一种特征。常用于人脸识别中五官划分，例如：脸部的一些特征能由矩形模块差值特征简单的描述，如：眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。但矩形特征只对一些简单的图形结构，如边缘、线段较敏感，所以只能描述在特定方向（水平、垂直、对角）上有明显像素模块梯度变化的图像结构。 它分为三类：边缘特征、线性特征、中心特征和对角线特征。 模板特征值计算： 黑色矩形像素和 - 白色矩形像素和 注：一般通过积分图计算Haar特征，这样只需求一次积分图，就可以求出多种Haar特征，节省计算时间 积分图：主要思想是将图像从起点开始到各个点所形成的矩形区域像素之和作为一个数组的元素保存在内存中，当要计算某个区域的像素和时可以直接索引数组的元素，不用重新计算这个区域的像素和。示例如下： 上图中，D块的像素和=II(4)+II(1)-II(2)-II(3) II表示积分图 2. 实现这里我只实现了Haar特征的一种，其他的同理1234567891011121314151617% 提取Haar特征（中心为黑四周为白），思路如下：% white+black = II(i+1,j+1)+II(i-2,j-1)-II(i-2,j+1)-II(i+1,j-2)% black = img(i,j)% harr = white-black = white+black-2*blackfunction [haar,hg,hgx,hgy] = edge_haar_center(img) close all; II = integralImage(img);% 求积分图 II = II(2:end,2:end); height = size(II,1); width = size(II,2); total = II(4:height-1,4:width-1)+II(1:height-4,1:width-4)-II(1:height-4,4:width-1)-II(4:height-1,1:width-4); black = img(3:height-2,3:width-2); haar = (total - 2*black); [hgx,hgy] = gradient(haar); hg = sqrt(hgx.^2+hgy.^2);end 参考资料 Canny边缘检测算法原理及其VC实现详解 Bilateral Filters（双边滤波算法）原理及实现 Hessian矩阵以及在图像中的应用 机器学习之Haar特征]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android项目开发笔记之身高年龄体重WheelView实现（单栏/双栏）]]></title>
      <url>%2F2018%2F03%2F11%2FAndroid%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BA%AB%E9%AB%98%E5%B9%B4%E9%BE%84%E4%BD%93%E9%87%8DWheelView%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%8D%95%E6%A0%8For%E5%8F%8C%E6%A0%8F%EF%BC%89%2F</url>
      <content type="text"><![CDATA[写在前面 本系列第三篇。本篇讲的是很常见的身高年龄选择器，可以定制成单栏或者双栏显示模式~ 实现效果单栏 双栏 步骤自定义布局类 新建WheelView类，继承ScrollView 该类的代码我放在gist上了，主要是参考了一份别人的代码，加上一点改动。 初始化数据源1234567891011121314151617181920 // 存储选项列表 private ArrayList&lt;String&gt; heightList = new ArrayList&lt;String&gt;(); private ArrayList&lt;String&gt; weightList = new ArrayList&lt;String&gt;(); private ArrayList&lt;String&gt; zeroToNineList = new ArrayList&lt;String&gt;(); private void initData()&#123; // 填充列表 heightList.clear(); weightList.clear(); zeroToNineList.clear(); for (int i = 150; i &lt;= 180; i++)&#123; heightList.add(i+""); // height: 150-180 &#125; for (int i = 30; i &lt;= 150; i++)&#123; weightList.add(i+""); // weight: 30.0-150.0 &#125; for (int i = 0; i &lt;= 9; i++)&#123; zeroToNineList.add(i+""); &#125; &#125; 动态创建对话框创建身高对话框（单栏）参数说明见后。 12345678910111213heightBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showChoiceDialog(R.id.wheel_view,heightList,heightBtn, new WheelView.OnWheelViewListener()&#123; @Override public void onSelected(int selectedIndex, String item) &#123; selectText = item; height = Float.parseFloat(item)/100.0f; &#125; &#125;); &#125;&#125;); 创建体重对话框（双栏）参数说明见后 12345678910111213141516171819202122232425262728weightBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; weight_Float = 0; weight_Int = 0; showChoiceDialog(R.id.wheel_view1, R.id.wheel_view2, weightList, zeroToNineList, weightBtn, new WheelView.OnWheelViewListener()&#123; @Override public void onSelected(int selectedIndex, String item) &#123; selectText_left = item; weight_Int = Integer.parseInt(item); weight = weight_Int + weight_Float * 0.1f; Log.d("WEIGHT",weight+""); &#125; &#125;, new WheelView.OnWheelViewListener()&#123; @Override public void onSelected(int selectedIndex, String item) &#123; selectText_right = item; weight_Float = Float.parseFloat(item); weight = weight_Int + weight_Float * 0.1f; Log.d("WEIGHT",weight+""); &#125; &#125; ); &#125;&#125;); 对话框实现与显示单滑动标尺对话框1234567891011121314151617181920212223242526272829303132private String selectText;/** * 单滑动标尺对话框 * @param wheelviewId 滑动标尺id * @param dataList 数据列表 * @param infoBtn 激活对话框的按钮（用于显示所选项） * @param listener 标尺滑动监听器 */private void showChoiceDialog(int wheelviewId, ArrayList&lt;String&gt; dataList, final Button infoBtn, WheelView.OnWheelViewListener listener)&#123; selectText = ""; View outerView = LayoutInflater.from(this.getActivity()).inflate(R.layout.dialog_wheelview, null); final WheelView wv = outerView.findViewById(wheelviewId); wv.setOffset(2);// 对话框中当前项上面和下面的项数 wv.setItems(dataList);// 设置数据源 wv.setSeletion(3);// 默认选中第三项 wv.setOnWheelViewListener(listener);// 显示对话框，点击确认后将所选项的值显示到Button上 new AlertDialog.Builder(this.getActivity()) .setView(outerView) .setPositiveButton("确认", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; infoBtn.setText(selectText); infoBtn.setTextColor(green); &#125; &#125;) .setNegativeButton("取消",null) .show();&#125; 双滑动标尺对话框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private String selectText_left;private String selectText_right;/** * 双滑动标尺对话框 * @param leftwheelviewId 左滑动标尺id * @param rightwheelviewId 右滑动标尺id * @param dataList_L 左数据列表 * @param dataList_R 右数据列表 * @param infoBtn 激活对话框的按钮（用于显示所选项） * @param leftListener 左栏滑动监听器 * @param rightListener 右栏滑动监听器 */private void showChoiceDialog(int leftwheelviewId, int rightwheelviewId, ArrayList&lt;String&gt; dataList_L, ArrayList&lt;String&gt; dataList_R, final Button infoBtn, WheelView.OnWheelViewListener leftListener, WheelView.OnWheelViewListener rightListener)&#123; selectText_left = ""; selectText_right = ""; View outerView = LayoutInflater.from(this.getActivity()).inflate(R.layout.dialog_twowheelview, null); final WheelView wv_L = outerView.findViewById(leftwheelviewId); wv_L.setOffset(2);// 对话框中当前项上面和下面的项数 wv_L.setItems(dataList_L);// 设置数据源 wv_L.setSeletion(3);// 默认初始选中第三项 wv_L.setOnWheelViewListener(leftListener); final WheelView wv_R = outerView.findViewById(rightwheelviewId); wv_R.setOffset(2);// 对话框中当前项上面和下面的项数 wv_R.setItems(dataList_R);// 设置数据源 wv_R.setSeletion(3);// 默认初始选中第三项 wv_R.setOnWheelViewListener(rightListener);// 显示对话框，点击确认后将所选项的值显示到Button上 new AlertDialog.Builder(this.getActivity()) .setView(outerView) .setPositiveButton("确认", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; String text = selectText_left + "." + selectText_right; infoBtn.setText(text); infoBtn.setTextColor(green); &#125; &#125;) .setNegativeButton("取消",null) .show();&#125; 最后以上，就实现了一个基本的单/双滑动标尺啦，虽然基本上放的都是代码= =不过注释写的算挺清楚的了，还有不清楚的可以留言呀~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android项目开发笔记之Material日历模块实现（支持滑动/直接选择年月）]]></title>
      <url>%2F2018%2F03%2F11%2FAndroid%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8BMaterial%E6%97%A5%E5%8E%86%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%94%AF%E6%8C%81%E6%BB%91%E5%8A%A8or%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E5%B9%B4%E6%9C%88%EF%BC%89%2F</url>
      <content type="text"><![CDATA[写在前面 本系列第二篇（隔了好久的感觉orz）。本篇主要讲的是很多App里都会有的日历模块实现，基于Github上一个优秀的开源项目进行了扩展，支持滑动切换月份以及下拉直接选择年月~ 实现效果先放一下实现的效果图： 引入插件 在app/build.gradle的dependencies中增加：compile &#39;com.haibin:calendarview:3.2.0&#39; 重新sync 定义布局123456789101112131415161718&lt;com.haibin.calendarview.CalendarView android:id="@+id/history_calendarView" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="5" android:background="@color/colorPrimary" app:month_view="你的包名.CustomMonthView" app:week_bar_view="你的包名.EnglishWeekbar" app:week_line_background="@color/white" app:calendar_height="37dp" app:current_day_text_color="#d94373" app:selected_theme_color="@color/white" app:lunar_text_size="0sp" app:min_year="2018" app:max_year="2050" app:month_view_show_mode="mode_all" app:other_month_text_color="#82ffffff" /&gt; 自定义MonthView(选中日期时效果 &amp; 特殊事件效果) 新建CustomMonthView.java,代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class CustomMonthView extends MonthView &#123; private int mRadius; public CustomMonthView(Context context) &#123; super(context); mSchemePaint.setColor(Color.WHITE); mSchemeTextPaint.setColor(Color.GREEN); &#125; @Override protected void onPreviewHook() &#123; mRadius = Math.min(mItemWidth, mItemHeight) / 5 * 2; mCurMonthTextPaint.setColor(Color.WHITE);// 白色圆圈 mSchemePaint.setStyle(Paint.Style.FILL); mSelectTextPaint.setColor(getResources().getColor(R.color.colorPrimary)); setLayerType( LAYER_TYPE_SOFTWARE , null); &#125; @Override protected void onLoopStart(int x, int y) &#123; &#125; @Override protected boolean onDrawSelected(Canvas canvas, Calendar calendar, int x, int y, boolean hasScheme) &#123; // 画白色圆圈 int cx = x + mItemWidth / 2; int cy = y + mItemHeight / 2; canvas.drawCircle(cx, cy, mRadius, mSelectedPaint); return false; &#125; @Override protected void onDrawScheme(Canvas canvas, Calendar calendar, int x, int y) &#123; // 画右上角白点，表示特殊日期 int cx = x + 4*mItemWidth / 5; int cy = y + mItemHeight / 5; canvas.drawCircle(cx, cy, mRadius/4, mSchemePaint); &#125; @Override protected void onDrawText(Canvas canvas, Calendar calendar, int x, int y, boolean hasScheme, boolean isSelected) &#123; float baselineY = mTextBaseLine + y; int cx = x + mItemWidth / 2; if (isSelected) &#123; canvas.drawText(String.valueOf(calendar.getDay()), cx, baselineY, mSelectTextPaint); &#125;else if (hasScheme) &#123; canvas.drawText(String.valueOf(calendar.getDay()), cx, baselineY, calendar.isCurrentDay() ? mCurDayTextPaint : calendar.isCurrentMonth() ? mSchemeTextPaint : mOtherMonthTextPaint); &#125; else &#123; canvas.drawText(String.valueOf(calendar.getDay()), cx, baselineY, calendar.isCurrentDay() ? mCurDayTextPaint : calendar.isCurrentMonth() ? mCurMonthTextPaint : mOtherMonthTextPaint); &#125; &#125;&#125; 自定义WeekBar（英文版）默认Weekbar是中文的，个人觉得英文的看起来比较舒服，所以自定义了一个，步骤如下： 新建english_weekbar.xml，内容是7个TextView,代表周一到周日，代码比较简单就不贴了 新建EnglishWeekbar.java,加载english_weekbar.xml布局,代码如下：123456public class EnglishWeekbar extends WeekBar &#123; public EnglishWeekbar(Context context) &#123; super(context); LayoutInflater.from(context).inflate(R.layout.english_week_bar, this, true); &#125;&#125; 制作下拉选择控件（使用Spinner）同样介绍一个github上的项目，可定制项比较丰富，且有Material效果。 引入：implementation &#39;com.jaredrummler:material-spinner:1.2.4@aar&#39; xml中使用：12345678910111213&lt;com.jaredrummler.materialspinner.MaterialSpinner android:id="@+id/dateSpinner" android:layout_width="150dp" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginStart="85dp" app:ms_background_color="@color/colorPrimary" app:ms_background_selector="@color/colorPrimary" app:ms_arrow_tint="@color/white" app:ms_dropdown_height="250dp" app:ms_hint_color="@color/black" app:ms_text_color="@color/white" android:textSize="18sp" /&gt; activity中往Spinner填充日期数据（范围为2018年-2050年）12345678910111213141516private int currentIndex;void initData()&#123; currentIndex = 1; int cur_year = Util.getYear(new Date()); int cur_month = Util.getMonth(new Date()); List&lt;String&gt; dateList = new ArrayList&lt;&gt;(); for(int year=2018; year&lt;=2050; year++)&#123; for(int month=1;month&lt;=12;month++)&#123; dateList.add(year+"-"+month); if(year &lt;= cur_year &amp;&amp; month &lt; cur_month) currentIndex++; &#125; &#125; dateSpinner.setItems(dateList);// 填充数据 dateSpinner.setSelectedIndex(currentIndex);// 默认选中当前月&#125; 控件组合 不难发现，上面定义的这两个控件其实是没有关系的，那么怎么实现滑动切换的时候，Spinner显示的日期也会改变，而下拉选择某月后，CalendarView又会滑动到目标月份呢？其实也不难，只需要监听二者相应的事件，再进行处理即可，具体步骤如下： 监听calendarView的onMonthChanged事件123456789101112131415// 滑动日历时更改Title显示,根据与当前月份的偏移量计算目标月份在Spinner中的索引值calendarView.setOnMonthChangeListener(new CalendarView.OnMonthChangeListener() &#123; @Override public void onMonthChange(int year, int month) &#123; int cur_month = calendarView.getCurMonth(); int cur_year = calendarView.getCurYear(); int offset; if(cur_year == year)&#123; offset = month - cur_month; &#125;else&#123; offset = (year - cur_year)*12 + month - cur_month; &#125; dateSpinner.setSelectedIndex(currentIndex + offset); &#125;&#125;); 监听dateSpinner的onItemSelected事件12345678910// 年月选择监听,提取点击项的年份及月份，滑动日历至目标月份dateSpinner.setOnItemSelectedListener(new MaterialSpinner.OnItemSelectedListener&lt;String&gt;() &#123; @Override public void onItemSelected(MaterialSpinner view, int position, long id, String item) &#123; String[] dateStr = item.split("-"); int year = Integer.parseInt(dateStr[0]); int month = Integer.parseInt(dateStr[1]); calendarView.scrollToCalendar(year,month,1); &#125;&#125;); 其他 使用calendarView.setSchemeDate(dateList)可以设置特殊日期 com.haibin.calendarview中也有一个Calendar类，不要和java.util.Calendar混了，特别在进行java.util.Date和calendar的转换时需要注意。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android项目开发笔记之登录注册模块实现（客户端+服务端）]]></title>
      <url>%2F2018%2F03%2F11%2FAndroid%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%2B%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89%2F</url>
      <content type="text"><![CDATA[写在前面 断断续续开发了几个月的App终于告一段落，虽然它可能还很不完美，不过作为上手Android的第一个完整项目，确实从中学到了蛮多，所以开个系列记录一下~本篇先从基本上每个App都会有的登录注册讲起，包含自动登录、记住密码功能的实现=w= 实现：登录功能思路 整个登录功能的逻辑为：用户提交账号、密码-&gt;判断账号密码是否为空-&gt;选项处理（自动登录及记住密码）-&gt;向服务端LoginServlet提交账号密码-&gt;服务端查询数据库判断账号是否存在-&gt;服务端查询数据库判断账号密码是否匹配-&gt;返回resCode（登录成功/失败） 客户端注： 客户端使用Litepal进行数据库的管理，关于Litepal的配置自行百度=。= 在LogInActivity启动时要先判断用户上次是否有勾选了自动登录或记住密码，这个是通过SharedPreferences实现的，代码如下： 12345678910111213141516171819202122232425@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); initComponents(); setListeners(); // 自动填充 SharedPreferencesUtil spu = new SharedPreferencesUtil(this); Boolean isRemember = (Boolean) spu.getParam("isRememberPwd",false); Boolean isAutoLogin = (Boolean) spu.getParam("isAutoLogin",false); // SharedPreference获取用户账号密码，存在则填充 String account = (String) spu.getParam("account",""); String pwd = (String)spu.getParam("pwd",""); if(!account.equals("") &amp;&amp; !pwd.equals(""))&#123; if(isRemember)&#123; accountText.setText(account); passwordText.setText(pwd); isRememberPwd.setChecked(true); &#125; if(isAutoLogin) Login(); &#125;&#125; 2.判断账号密码是否合理，这里设置为只有手机/邮箱才能登录 1234567private String checkDataValid(String account,String pwd)&#123; if(TextUtils.isEmpty(account) | TextUtils.isEmpty(pwd)) return "账号或密码不能为空"; if(account.length() != 11 &amp;&amp; !account.contains("@")) return "用户名不是有效的手机或邮箱"; return "";&#125; 3.记录自动登录及记住密码选项，同时将最近登录的账号密码写入SharedPreferences中123456789101112131415161718void OptionHandle(String account,String pwd)&#123; SharedPreferences.Editor editor = getSharedPreferences("UserData",MODE_PRIVATE).edit(); SharedPreferencesUtil spu = new SharedPreferencesUtil(this); if(isRememberPwd.isChecked())&#123; editor.putBoolean("isRememberPwd",true); // 保存账号密码 spu.setParam("account",account); spu.setParam("pwd",pwd); &#125;else&#123; editor.putBoolean("isRememberPwd",false); &#125; if(isAutoLogin.isChecked())&#123; editor.putBoolean("isAutoLogin",true); &#125;else&#123; editor.putBoolean("isAutoLogin",false); &#125; editor.apply();&#125; 4.向服务端发起POST请求，这里将账号密码封装为JSON字符串后再提交，JSON的好处大家都懂得~123456789101112131415161718192021222324252627282930313233343536// 登录请求public void LoginPost(String account, String password, final Handler mHandler)&#123; final CommonRequest request = new CommonRequest(); // 填充参数 request.addRequestParam("account",account); request.addRequestParam("pwd",password); infoPost(Consts.URL_Login, request.getJsonStr()); // 隔一段时间（2.5s）后再发送信息给LogInActivity，因为网络请求是耗时操作 mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Message message = new Message(); message.what = 1; mHandler.sendMessage(message); &#125; &#125;, 2500);&#125;// 通用的POST信息方法private void infoPost(String url, String json)&#123; HttpUtil.sendPost(url,json,new okhttp3.Callback() &#123; @Override public void onResponse(Call call, Response response) throws IOException &#123; CommonResponse res = new CommonResponse(response.body().string()); resCode = res.getResCode(); resMsg = res.getResMsg(); property = res.getPropertyMap(); dataList = res.getDataList(); &#125; @Override public void onFailure(Call call, IOException e) &#123; e.printStackTrace(); showResponse("Network ERROR"); &#125; &#125;);&#125; 5.以上3步合起来即为Login方法，代码如下:12345678910111213141516171819202122232425/** * POST方式Login */private void Login() &#123; // 前端参数校验，防SQL注入 account = Util.StringHandle(accountText.getText().toString()); password = Util.StringHandle(passwordText.getText().toString()); // 检查数据格式是否正确 String resMsg = checkDataValid(account,password); if(!resMsg.equals(""))&#123; showResponse(resMsg); return; &#125; // 显示进度条 progressDialog = new ProgressDialog(this); progressDialog.setMessage("登录中..."); progressDialog.setCancelable(false); progressDialog.show(); OptionHandle(account,password);// 处理自动登录及记住密码 server.LoginPost(account,password,loginHandler);&#125; 6.loginHandler根据得到的登录状态码进行相应处理：1234567891011121314151617181920212223242526272829@SuppressLint("HandlerLeak")Handler loginHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 1: String resCode = server.getResCode(); String resMsg = server.getResMsg(); // 登录成功 if (resCode != null &amp;&amp; resCode.equals(Consts.SUCCESSCODE_LOGIN)) &#123; // 查找本地数据库中是否已存在当前用户,不存在则新建用户并写入 User user = DataSupport.where("account=?",account).findFirst(User.class); if(user == null)&#123; user = new User(); user.setAccount(account); user.setPassword(password); user.setVisitor(false); user.save(); &#125; UserManager.setCurrentUser(user);// 设置当前用户 autoStartActivity(MainActivity.class); &#125; progressDialog.dismiss();// 隐藏进度条 showResponse(resMsg);// Toast相应信息 break; &#125; &#125;&#125;; 服务端注：服务端使用Java Servlet实现，这个网上也有很多资料，不多说 因为使用的是POST方式，所以以下步骤均在Servlet的**doPost**中进行; 获取客户端发来的请求，将request对象转化为字符串，进而恢复其JSON格式12345678910// request转字符串BufferedReader read = request.getReader();StringBuilder sb = new StringBuilder();String line = null;while ((line = read.readLine()) != null) &#123; sb.append(line);&#125;String req = sb.toString();// 获取 客户端 发来的请求，恢复其Json格式——&gt;需要客户端发请求时也封装成Json格式JSONObject object = JSONObject.fromObject(req); 提取json中的requestCode和requestParam，requestCode可以用于区分同一类请求下的不同子请求，eg.获取数据库的不同信息123// requestCode、requestParam要和客户端CommonRequest封装时候的名字一致 String requestCode = object.getString("requestCode"); // 暂时不用JSONObject requestParam = object.getJSONObject("requestParam"); 提取账号密码 123// json中提取参数String account = requestParam.getString("account");String pwd = requestParam.getString("pwd"); 定义查询语句、查询结果集、Response信息对象 123456789// 自定义的结果信息类 CommonResponse res = new CommonResponse(); // Sql查询语句String sqlQueryExist = "select * from "+DBUtil.table_user_pwd+" where username=?;";// 查询结果ResultSet resultSet = null;ArrayList&lt;String&gt; args = new ArrayList&lt;String&gt;(); 核心逻辑：填充查询参数-&gt;执行查询语句-&gt;判断账号是否存在-&gt;若存在则查询密码是否匹配-&gt;否则返回错误信息 12345678910111213141516try &#123; args.add(account); resultSet = DBUtil.query(sqlQueryExist, args); if(resultSet.next())&#123;// 账号存在，查询密码是否正确 if(resultSet.getString("pwd").equals(pwd))&#123;// 密码正确 res.setResult("100", "登录成功！"); &#125;else&#123;// 密码错误 res.setResult("201", "密码错误！"); &#125; &#125;else&#123;// 账号不存在 res.setResult("202", "账号不存在，请先注册！"); &#125;&#125; catch (Exception e) &#123; res.setResult("300", "数据库查询错误"); e.printStackTrace();&#125; 将结果封装为Json格式返回给客户端 123// 注意实际网络传输时还是传输json的字符串String resStr = JSONObject.fromObject(res).toString();response.getWriter().append(resStr).flush(); 实现：注册功能思路 注册功能逻辑为：用户提交账号、密码、确认密码-&gt;判断三者是否均不为空-&gt;判断两次输入的密码是否一致-&gt;判断用户名是否合理-&gt;提交账号密码至服务端-&gt;服务端查询账号是否已存在-&gt;若不存在则插入账号密码至user_pwd表中-&gt;向客户端返回信息 客户端注释写的很清楚了，直接放源码~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * POST方式Register */private void register() &#123; // 创建请求体对象 CommonRequest request = new CommonRequest(); // 前端参数校验，防SQL注入 String account = Util.StringHandle(accountText.getText().toString()); String pwd = Util.StringHandle(pwdText.getText().toString()); String pwd_confirm = Util.StringHandle(confirmPwdText.getText().toString()); // 检查数据格式是否正确 String resMsg = checkDataValid(account,pwd,pwd_confirm); if(!resMsg.equals(""))&#123; showResponse(resMsg); return; &#125; // 填充参数 request.addRequestParam("account",account); request.addRequestParam("pwd",pwd); // POST请求 HttpUtil.sendPost(Consts.URL_Register, request.getJsonStr(), new okhttp3.Callback() &#123; @Override public void onResponse(Call call, Response response) throws IOException &#123; CommonResponse res = new CommonResponse(response.body().string()); String resCode = res.getResCode(); String resMsg = res.getResMsg(); // 显示注册结果 showResponse(resMsg); // 注册成功 if (resCode.equals(Consts.SUCCESSCODE_REGISTER)) &#123; finish(); &#125; &#125; @Override public void onFailure(Call call, IOException e) &#123; e.printStackTrace(); showResponse("Network ERROR"); &#125; &#125;);&#125;private String checkDataValid(String account,String pwd,String pwd_confirm)&#123; if(TextUtils.isEmpty(account) | TextUtils.isEmpty(pwd) | TextUtils.isEmpty(pwd_confirm)) return "账号或密码不能为空"; if(!pwd.equals(pwd_confirm)) return "两次输入的密码需保持一致"; if(account.length() != 11 &amp;&amp; !account.contains("@")) return "用户名不是有效的手机号或邮箱"; return "";&#125; 服务端 1-4步与登录功能里的一致，不再赘述 核心逻辑：填充查询参数-&gt;查询账号是否存在-&gt;若不存在执行Insert操作，同时更新userInfo表-&gt;向客户端返回消息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 自定义的结果信息类 CommonResponse res = new CommonResponse(); // Sql语句String sqlQueryExist = "select * from "+DBUtil.table_user_pwd+" where username=?;";String sqlInsert = "insert into "+DBUtil.table_user_pwd+"(username,pwd)"+ " values(?,?);";// 查询结果ResultSet resultSet = null;ArrayList&lt;String&gt; args = new ArrayList&lt;String&gt;();try &#123; DBUtil.checkConnection(); args.add(account); resultSet = DBUtil.query(sqlQueryExist, args); if(resultSet.next())&#123;// resSet不为空 res.setResult("203", "账号已存在，请登录"); &#125;else&#123; args.add(pwd); int rows = DBUtil.update(sqlInsert, args);// 返回插入后受影响的行数 if(rows==1)&#123;// 插入userpwd表成功 String sqlQueryId = "select userId from "+DBUtil.table_user_pwd+ " where username=?;"; args.clear(); args.add(account); ResultSet resSet = DBUtil.query(sqlQueryId, args); if(resSet.next())&#123; // 获取用户id,更新userInfo表 String userId = resSet.getInt("userId")+""; String sqlInsertId = "insert into "+DBUtil.table_user_info+ "(userId)"+" values(?);"; args.clear(); args.add(userId); rows = DBUtil.update(sqlInsertId, args); if(rows == 1 )&#123; res.setResult("101", "注册成功"); &#125; &#125; &#125;else&#123; res.setResult("204", "用户信息插入失败"); &#125; &#125;&#125; catch (SQLException e) &#123; res.setResult("300", "数据库查询错误"); e.printStackTrace();&#125; // 将结果封装成Json格式准备返回给客户端，但实际网络传输时还是传输json的字符串String resStr = JSONObject.fromObject(res).toString();response.getWriter().append(resStr).flush(); 最后 登录注册模块到这里就完成啦！里面涉及到一些功能类和功能函数的封装，不难实现，源码放Github了，欢迎star~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[自制工具]实现自动推送Hexo博客文章至百度]]></title>
      <url>%2F2017%2F11%2F23%2F%5B%E8%87%AA%E5%88%B6%E5%B7%A5%E5%85%B7%5D%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E8%87%B3%E7%99%BE%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[写在前面 我们在博客发布文章时，总是希望百度能尽快收录我们的文章，但是如果傻傻等百度爬虫爬到我们这种小站点的文章……不知道要等到何年何月= =基于此，百度站长平台提供了主动推送文章至百度的接口。但是这个接口要求我们先把所有文章的URL一行一个写入urls.txt中。然而还是太麻烦了，每次写完文章还得再自己手动更新urls.txt。所以，我用python做了一个小工具，可以一键/一条命令自动推送所有文章至百度~适合我这种懒人使用2333 工具介绍原理 原理其实很简单粗暴——就是写个爬虫爬取你博客里的所有文章URL，然后逐行写入urls.txt，再使用百度站长平台提供的接口完成推送。恩，听上去就是这么简单……然而渣渣如我在制作过程中还是遇到了不少问题，略去不表= = 使用前提 确保电脑中已安装python; 确保已安装pyyaml模块，安装方法：pip install pyyaml Ubuntu用户请确保已安装curl命令，安装方法：sudo apt install curl 确保你的博客基于Hexo搭建且主题为Next | Jacman | Yelee | Apollo【暂时只测试了这几个主题，后续有需要的话再增加】; 有百度站长平台账号且已绑定你的博客站点，方法平台里写的很清楚了; 步骤Windows： 直接在我的项目主页 download zip 或者 git bash下执行git clone https://github.com/Lemon-XQ/Hexo-BaiduPushTool.git 打开_urlconfig.yml，填入你的博客地址、使用主题、百度主动推送接口，保存 双击baidupush.bat文件，等待推送完成 Linux： git clone https://github.com/Lemon-XQ/Hexo-BaiduPushTool.git cd Hexo-BaiduPushTool vi _urlconfig.yml 填写相应信息后保存退出 python BaiduPush.py 等待推送完成 效果预览 注意填写配置文件时，请注意yaml语法！即URL:后需加一个空格！否则会报错 最后 源码见github，如果有bug或者是建议麻烦跟我说一下啦~如果觉得还行的话给个star就更好啦（比心）~最后,github求一波互粉呀（逃]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo之静态+动态背景设置]]></title>
      <url>%2F2017%2F11%2F20%2FHexo%E4%B9%8B%E9%9D%99%E6%80%81%2B%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[写在前面 实现背景图更换及平铺，以及引入动态背景（可交互） 静态background设置 打开博客根目录/themes/next/source/css/_custom/custom.styl文件，编辑如下： 1234567// Custom styles.body &#123; background-image: url(/images/background.png); background-attachment: fixed; // 不随屏幕滚动而滚动 background-repeat: repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: contain; // 等比例铺满屏幕&#125; 将背景图命名为background.png并放入主题根目录/images下 动态可交互背景（js引入） 打开博客根目录/themes/next/layout/_layout.swig文件，在之前添加代码如下：1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 属性说明： color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 2.打开博客根目录/themes/next/_config.yml，找到字段canvas_nest，将其置为true【如果没有找到该字段，请自行添加】3.hexo clean , hexo d -g可以看到效果~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo之使用CodingPages实现全站Https]]></title>
      <url>%2F2017%2F11%2F20%2FHexo%E4%B9%8B%E4%BD%BF%E7%94%A8CodingPages%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99Https%2F</url>
      <content type="text"><![CDATA[拒绝让自己的网站成为不安全的网站：） 写在前面 之前博客单线部署在Github Pages的时候，用的是cloudflare提供的SSL证书。但是cloudflare只能绑定一个CNAME记录（而且好像只能绑github.io？），所以后面双线部署（GitHub Pages+Coding Pages）后，cloudflare就不能用了。不过好在Coding Pages提供了通过Let’s Encrypt申请SSL证书进而开启全站HTTPs的方法。下面记录一下步骤~ 步骤 首先确保你的博客已经部署在Coding Pages上并且已经添加CNAME记录，不懂的先参照我的另一篇博客中关于域名绑定的部分 申请SSL证书【注意：如果是Github+Coding双线部署，申请SSL证书前需要先将解析到github.io的CNAME记录暂停！！！不然Let’s Encrypt主机在验证域名所有权时会定位到Github Pages的主机上导致SSL证书申请失败】 等待10分钟左右申请成功 强制开启Https 后续开启强制HTTPS访问后，网站内引用资源的URL必须以https:// 开头，避免引用资源加载失败。例如Css文件、JavaScript文件、Image文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo之使用Livere评论代替多说评论]]></title>
      <url>%2F2017%2F11%2F20%2FHexo%E4%B9%8B%E4%BD%BF%E7%94%A8Livere%E8%AF%84%E8%AE%BA%E4%BB%A3%E6%9B%BF%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[写在前面 由于众所周知的原因，多说评论和网易云跟帖先后都宣布关闭评论服务，一直没有找到好的替换方案。昨天无意看到韩国的Livere（来必力）评论，瞬间就喜欢上了~UI好看，加载时候的那个小幽灵也好可爱=w=而且是国外的，应该没那么容易关闭吧2333下面记录一下步骤~ 准备 去Livere官网注册Livere账号。 选择City版（免费），安装 进入管理页面-&gt;代码管理-&gt;一般网站，复制data-uid 在Hexo中添加Livere以下基于主题Next，其他主题做法类似 打开博客根目录/themes/next/_config.yml 将# Third Party Services Settings 栏目下其他评论系统如duoshuo、gentie、youyan、disqus用#注释掉，加入以下内容 12# Livere评论系统livere_uid: 上一步中你获取的data-uid 在博客根目录/themes/layout/_scripts/third-party/comments/目录中新建txt文件，重命名为livere.swig，编辑内容如下： 12345678910111213141516&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 在博客根目录/themes/layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include &apos;./comments/livere.swig&apos; %&#125; 在博客根目录/themes/layout/_partials/comments.swig文件中条件最后追加 LiveRe 插件是否引用的判断逻辑： 123&#123;% elseif theme.livere_uid %&#125; &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&#123;&#123; theme.livere_uid &#125;&#125;&quot;&gt;&lt;/div&gt;&#123;% endif %&#125; 重新hexo clean、hexo d -g，然后就可以看到来必力评论啦~【PS：不知道为啥我刚部署完的时候评论没有出现……可能要等一会？】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现在Java中执行python代码或py脚本（可传参数）]]></title>
      <url>%2F2017%2F11%2F17%2F%E5%AE%9E%E7%8E%B0%E5%9C%A8Java%E4%B8%AD%E6%89%A7%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E6%88%96py%E8%84%9A%E6%9C%AC%EF%BC%88%E5%8F%AF%E4%BC%A0%E5%8F%82%E6%95%B0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[写在前面 最近用Java写服务端程序时，遇到这样一个需求：需要把用python写的机器学习算法部署到服务器上，然后Java执行py脚本，并且取得算法执行的结果。在网上找了很久，有些跑不通，有些是基于windows的，我的服务器是linux的，遇到了不少坑= =好不容易解决了，记录一下。 注：Web服务器：Tomcat 服务器OS：CentOS 7 开发工具：Eclipse 直接嵌入python代码(使用PythonInterpreter) 适用情形：要嵌入的python代码不长 步骤： 下载Jython，导入jython.jar到项目lib中 引用org.python包 测试代码如下：123456789101112import javax.script.*; import org.python.util.PythonInterpreter; import java.io.*; import static java.lang.System.*; public class Test &#123; public static void main(String args[]) &#123; PythonInterpreter interpreter = new PythonInterpreter(); interpreter.exec("print "TEST";"); &#125;&#125; 执行python脚本(使用PythonInterpreter) 适用情形：python代码为py文件形式 步骤： 下载Jython，导入jython.jar到项目lib中 引用org.python包 测试代码如下：1234567891011121314import javax.script.*; import org.python.util.PythonInterpreter; import java.io.*; import static java.lang.System.*; public class Test &#123; public static void main(String args[]) &#123; PythonInterpreter interpreter = new PythonInterpreter(); InputStream filepy = new FileInputStream("D:\\demo.py"); interpreter.execfile(filepy); filepy.close(); &#125; &#125; 执行python脚本(使用Runtime.getRuntime()） 适用情形： python脚本中import了外来模块； 需要传入数据给python脚本 PS:上面两种不知道为啥老是会报错= =所以最后我用的是这种…… 测试代码：12345678910111213141516171819202122232425262728293031323334353637// 定义传入参数int age;// 接收python脚本的输出结果int result;// 若Python脚本在windows主机中String cmdStr_windows = "python D:\\demo.py"+ " " + age;// 若Python脚本在Linux主机中String cmdStr_linux = "python /home/pythonCode/demo.py"+ " " + age);// 定义缓冲区、正常结果输出流、错误信息输出流byte[] buffer = new byte[1024]; ByteArrayOutputStream outStream = new ByteArrayOutputStream(); ByteArrayOutputStream outerrStream = new ByteArrayOutputStream(); try &#123; proc = Runtime.getRuntime().exec(cmdStr_linux); InputStream errStream = proc.getErrorStream(); InputStream stream = proc.getInputStream(); // 流读取与写入 int len = -1; while ((len = errStream.read(buffer)) != -1) &#123; outerrStream.write(buffer, 0, len); &#125; while ((len = stream.read(buffer)) != -1) &#123; outStream.write(buffer, 0, len); &#125; proc.waitFor();// 等待命令执行完成 // 打印流信息 System.out.println(outStream.toString()); System.out.println(outerrStream.toString()); // 将接收的输出结果转换为目标类型 res = Integer.parseInt(outStream.toString());&#125; catch (Exception e) &#123; e.printStackTrace();&#125; demo.py脚本如下： 1234import sysage = sys.argv[1]res = 1111print res 注： 若python脚本在Linux主机中，注意文件路径要为绝对路径，而且不能用~代替家目录！！！必须写成/XX/XXX的形式 若要传递多个参数，需要以空格间隔 接收python脚本执行结果可用java的InputStream截获控制台输出]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows下迁移指定MySQL数据库至Linux]]></title>
      <url>%2F2017%2F11%2F14%2FWindows%E4%B8%8B%E8%BF%81%E7%A7%BB%E6%8C%87%E5%AE%9AMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%B3Linux%2F</url>
      <content type="text"><![CDATA[写在前面 最近有个项目，需要把部署在Windows下的mysql数据库迁移到linux服务器中，且只迁移该项目的数据库。记录一下步骤。 注：本步骤基于cent os 7，使用的远程ssh工具为XShell5,数据库管理工具为Navicat for MySQL。迁移之前请确保两台主机已安装配置好MySQL数据库。 使用sql脚本文件迁移Windows（迁出数据库主机） 打开Navicat，在项目所在数据库处，右键-&gt;转储SQL文件 导出sql文件成功 Linux（迁入数据库主机） 打开XShell， ssh连接Linux主机（CentOS7） 将windows下导出的sql文件上传至Linux主机中，这里以XShell提供的ZMODEM文件传输工具为例。 yum install lrzsz 下载远程上传下载工具 cd 指定文件夹 rz上传导出的sql文件（若上传失败请使用rz -E命令） 执行sql脚本文件 mysql -u root -p 输入密码后进入mysql命令行 create database 项目数据库名; use 项目数据库名; source 路径/XXX.sql 执行成功，show tables;可以看到已经导入的表 使用mysqldump命令迁移Windows（迁出数据库主机） 打开cmd，执行mysqldump命令导出dump文件 mysqldump -u root -p test &gt; test.dump 回车后输入密码 导出dump文件成功(包括建表及插入语句等) Linux（迁入数据库主机） 打开XShell， ssh连接Linux主机（CentOS7） 将windows下导出的dump文件上传至Linux主机中，步骤同上 从备份的dump文件恢复数据库 mysql test &lt; test.dump]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unity对象池技术（原理+实战）]]></title>
      <url>%2F2017%2F08%2F13%2FUnity%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8E%9F%E7%90%86-%E5%AE%9E%E6%88%98%EF%BC%89%2F</url>
      <content type="text"><![CDATA[写在前面 很早就听说过对象池技术……然而一直到这几天才真正去了解= =。还得感谢Jasper Flick的博客，这里推荐他的Unity C# Tutorials系列，目前我只看了前几篇，收获还是挺大的~本篇博客也是基于这个系列中的一篇——Object Pools，加上个人的一些理解，对Unity的对象池技术进行简单介绍。 对象池简介 顾名思义，对象池是存放对象的缓冲区。用户可以从缓冲区中放入/取出对象。一类对象池存放一类特定的对象。那么对象池有什么用呢？在游戏中，经常会有产生/销毁大量同类游戏对象的需求，比如游戏中源源不断的敌人、频繁刷新的宝箱、乃至一些游戏特效（风、雨等）。如果没有一种比较好的机制来管理这些对象的产生和销毁，而是一昧的Instantiate和Destroy，将使你的游戏性能大大下降，甚至出现卡死、崩溃…… 对象池实现 简而言之，就是当需要使用一个对象的时候，直接从该类对象的对象池中取出（SetActive(true)），如果对象池中无可用对象，再进行Instantitate。而当不再需要该对象时，不直接进行Destroy,而是SetActive(false)并将其回收到对象池中。下面直接贴下代码： PooledObject.cs12345678910111213141516171819202122232425262728293031323334353637383940using UnityEngine;/// &lt;summary&gt;/// 所有需要使用对象池机制的对象的基类/// &lt;/summary&gt;public class PooledObject : MonoBehaviour&#123; // 归属的池 public ObjectPool Pool &#123; get; set; &#125; // 场景中某个具体的池（不可序列化） [System.NonSerialized] private ObjectPool poolInstanceForPrefab; /// &lt;summary&gt; /// 回收对象到对象池中 /// &lt;/summary&gt; public void ReturnToPool() &#123; if (Pool) &#123; Pool.AddObject(this); &#125; else &#123; Destroy(gameObject); &#125; &#125; /// &lt;summary&gt; /// 返回对象池中可用对象的实例 /// &lt;/summary&gt; public T GetPooledInstance&lt;T&gt;() where T : PooledObject &#123; if (!poolInstanceForPrefab) &#123; poolInstanceForPrefab = ObjectPool.GetPool(this); &#125; return (T)poolInstanceForPrefab.GetObject(); &#125;&#125; ObjectPool.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using UnityEngine;using System.Collections.Generic;public class ObjectPool : MonoBehaviour&#123; // 池中对象prefab private PooledObject prefab; // 存储可用对象的缓冲区 private List&lt;PooledObject&gt; availableObjects = new List&lt;PooledObject&gt;(); /// &lt;summary&gt; /// 从池中取出对象，返回该对象 /// &lt;/summary&gt; public PooledObject GetObject() &#123; PooledObject obj; int lastAvailableIndex = availableObjects.Count - 1; if (lastAvailableIndex &gt;= 0) &#123; obj = availableObjects[lastAvailableIndex]; availableObjects.RemoveAt(lastAvailableIndex); obj.gameObject.SetActive(true); &#125; else // 池中无可用obj &#123; obj = Instantiate&lt;PooledObject&gt;(prefab); obj.transform.SetParent(transform, false); obj.Pool = this; &#125; return obj; &#125; /// &lt;summary&gt; /// 向池中放入obj /// &lt;/summary&gt; public void AddObject(PooledObject obj) &#123; obj.gameObject.SetActive(false); availableObjects.Add(obj); &#125; /// &lt;summary&gt; /// 【静态方法】创建并返回对象所属的对象池 /// &lt;/summary&gt; public static ObjectPool GetPool(PooledObject prefab) &#123; GameObject obj; ObjectPool pool; // 编辑器模式下检查是否有同名pool存在，防止重复创建pool if (Application.isEditor) &#123; obj = GameObject.Find(prefab.name + " Pool"); if (obj) &#123; pool = obj.GetComponent&lt;ObjectPool&gt;(); if (pool) &#123; return pool; &#125; &#125; &#125; obj = new GameObject(prefab.name + " Pool"); DontDestroyOnLoad(obj); pool = obj.AddComponent&lt;ObjectPool&gt;(); pool.prefab = prefab; return pool; &#125;&#125; 实战：七彩喷泉【注：以下译至前面提到的Object Pools一文，有部分删减】 1.实现效果： 2.生成大量物体 首先新建脚本Stuff.cs，代码如下：1234567891011using UnityEngine;[RequireComponent(typeof(Rigidbody))]public class Stuff : MonoBehaviour &#123; Rigidbody body; void Awake () &#123; body = GetComponent&lt;Rigidbody&gt;(); &#125;&#125; 创建Cube和Sphere，挂上Stuff脚本。并将它们做成Prefab 接下来需要创建StuffSpawner（孵化器），并挂上StuffSpawner脚本，代码如下：123456789101112131415161718192021222324using UnityEngine;public class StuffSpawner : MonoBehaviour &#123; public float timeBetweenSpawns; public Stuff[] stuffPrefabs; float timeSinceLastSpawn; void FixedUpdate () &#123; timeSinceLastSpawn += Time.deltaTime; if (timeSinceLastSpawn &gt;= timeBetweenSpawns) &#123; timeSinceLastSpawn -= timeBetweenSpawns; SpawnStuff(); &#125; &#125; void SpawnStuff () &#123; Stuff prefab = stuffPrefabs[Random.Range(0, stuffPrefabs.Length)]; Stuff spawn = Instantiate&lt;Stuff&gt;(prefab); spawn.transform.localPosition = transform.position; &#125;&#125; 现在我们有了孵化器，可以在一个点产生Cube和Sphere，但这还不够。我们可以给这些stuff一个初始速度及方向。12345678public float velocity;void SpawnStuff () &#123; Stuff prefab = stuffPrefabs[Random.Range(0, stuffPrefabs.Length)]; Stuff spawn = Instantiate&lt;Stuff&gt;(prefab); spawn.transform.localPosition = transform.position; spawn.Body.velocity = transform.up * velocity;&#125; 运行一下可以发现一个个物体上升又下降，周而复始。如果你倾斜一下孵化器，会让它看上去更像流动的物体。事实上，如果我们把多个孵化器分布在一个环上，将得到类似喷泉的效果。因此，新建一个空物体StuffSpawnerRing，挂上如下脚本：123456789101112131415161718192021222324252627using UnityEngine;public class StuffSpawnerRing : MonoBehaviour &#123; public int numberOfSpawners; public float radius, tiltAngle; public StuffSpawner spawnerPrefab; void Awake () &#123; for (int i = 0; i &lt; numberOfSpawners; i++) &#123; CreateSpawner(i); &#125; &#125;&#125; void CreateSpawner (int index) &#123; Transform rotater = new GameObject("Rotater").transform; rotater.SetParent(transform, false); rotater.localRotation = Quaternion.Euler(0f, index * 360f / numberOfSpawners, 0f); StuffSpawner spawner = Instantiate&lt;StuffSpawner&gt;(spawnerPrefab); spawner.transform.SetParent(rotater, false); spawner.transform.localPosition = new Vector3(0f, 0f, radius); spawner.transform.localRotation = Quaternion.Euler(tiltAngle, 0f, 0f); &#125; 现在将场景中的Spawner做成prefab并删除，调整SpawnerRing的参数3.添加销毁区（KillZone） 我们现在得到了无止尽生成的下落的物体。为了防止程序卡顿，我们需要引入销毁区。所有进入销毁区的物体都要被销毁。 创建一个带有Box Collider的物体，设置为触发器，为Collider设置一个非常大的size（如1000），并将其放置在喷泉下方某个位置。最后给该物体添加一个Tag以便能被正确识别 重新编辑Stuff.cs，添加触发器事件处理12345void OnTriggerEnter (Collider enteredCollider) &#123; if (enteredCollider.CompareTag("Kill Zone")) &#123; Destroy(gameObject); &#125;&#125; 4.加入可变因素 目前我们的喷泉缺少随机性，我们可以用随机值代替固定值。因为我们要处理多个数据，所以让我们创建一个结构体来更好地实现随机化。12345678910111213using UnityEngine;[System.Serializable]public struct FloatRange &#123; public float min, max; public float RandomInRange &#123; get &#123; return Random.Range(min, max); &#125; &#125;&#125; 随机化生成时间123456789101112public FloatRange timeBetweenSpawns;float currentSpawnDelay;void FixedUpdate () &#123; timeSinceLastSpawn += Time.deltaTime; if (timeSinceLastSpawn &gt;= currentSpawnDelay) &#123; timeSinceLastSpawn -= currentSpawnDelay; currentSpawnDelay = timeBetweenSpawns.RandomInRange; SpawnStuff(); &#125;&#125; 随机化物体scale和rotation123456789101112public FloatRange timeBetweenSpawns, scale;void SpawnStuff () &#123; Stuff prefab = stuffPrefabs[Random.Range(0, stuffPrefabs.Length)]; Stuff spawn = Instantiate&lt;Stuff&gt;(prefab); spawn.transform.localPosition = transform.position; spawn.transform.localScale = Vector3.one * scale.RandomInRange; spawn.transform.localRotation = Random.rotation; spawn.Body.velocity = transform.up * velocity;&#125; 随机化物体速度大小12345678public FloatRange timeBetweenSpawns, scale, randomVelocity;void SpawnStuff () &#123; … spawn.Body.velocity = transform.up * velocity + Random.onUnitSphere * randomVelocity.RandomInRange;&#125; 随机化物体角速度12345678void SpawnStuff () &#123; … spawn.Body.velocity = transform.up * velocity + Random.onUnitSphere * randomVelocity.RandomInRange; spawn.Body.angularVelocity = Random.onUnitSphere * angularVelocity.RandomInRange;&#125; 随机化材质（实现七彩）1234567public Material[] stuffMaterials;void CreateSpawner (int index) &#123; … spawner.stuffMaterial = stuffMaterials[index % stuffMaterials.Length];&#125; 5.应用对象池进行管理 让Stuff继承PooledObject(PooledObject代码见前)，修改触发器事件，进入销毁区时不Destroy，而是调用ReturnToPool方法。 接下来，我们需要改变StuffSpawner来让它使用对象池来创建对象，而不是直接Instanstiate。如何做到呢？某种程度上我们需要拥有每个prefab的池，但我们不想要重复的池，也就是说所有孵化器都共享他们。当然，如果我们能直接从一个prefab得到一个池化的实例而不用考虑那些池本身将更加方便。123456void SpawnStuff () &#123; Stuff prefab = stuffPrefabs[Random.Range(0, stuffPrefabs.Length)]; Stuff spawn = prefab.GetPooledInstance&lt;Stuff&gt;(); …&#125; 其他 并非所有的对象都适合使用对象池来管理。需要在“对象生成的开销”以及“维护对象池的开销”之间进行权衡。 为避免在场景切换时重新生成pool，从而带来性能损耗，可在代码中加入DontDestroyOnLoad(pool) 同样，在场景切换时，应该将原场景中的对象回收进相应对象池中。即在OnLevelWasLoaded方法中调用ReturnToPool方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ulua热更新小试]]></title>
      <url>%2F2017%2F05%2F01%2Fulua%E7%83%AD%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AF%95%2F</url>
      <content type="text"><![CDATA[传说中的热更新在Unity中是怎样实现的:) 写在前面 热更新技术在游戏行业可以说是大名鼎鼎了，虽然苹果前段时间禁止了JSPatch等热更新技术，但目前来看，苹果并没有禁止游戏引擎的热更新技术。某种程度上说明了热更新在游戏中的重要性。而ulua作为一款优秀的unity3d热更新插件，完美解决了Unity游戏热更新的问题。 什么是热更新 热更新一般用于网络游戏中。其指的是在不重新下载客户端的情况下，对游戏的内容进行更新（包括资源更新或逻辑更新等）。知乎上对热更新有一个很形象的比喻：假设你的卡车开到了150KM/H，然后有个轮胎爆了。司机说，你就直接换吧，我不停车。你小心点换。热更新机制大概就是这个意思。 什么是Lua Lua是一款轻巧的脚本语言，由标准C编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。（嗯这段其实是百度的orz…） Lua代码都是运行时才编译的，不运行的时候就如同一张图片、一段音频一样，都是文件；所以更新逻辑只需要更新脚本，不需要再编译，因而Lua能轻松实现“热更新”。Ulua是一款非常实用的unity插件，它能让unity支持Lua语言，而且运行效率还不错。 使用ulua进行热更新1.安装ulua插件 及 Lua编写工具LuaStudio ulua下载地址：http://ulua.org/ LuaStudio下载地址：https://pan.baidu.com/s/1hsabx0w 密码: kqvp 2.新建Unity工程，将ulua导入工程中3.ulua中的使用流程 实例化LuaState对象（new LuaState()）,一个LuaState对象代表一个Lua解释器 加载Lua代码（LuaState.DoString(string)），string为Lua代码字符串或Lua脚本文件名称（推荐使用后者） 调用Lua代码中的方法（GetFunction string）,LuaFunction.callFunction(string) 注：由于Unity不支持扩展名为lua的文件，所以可将Lua脚本扩展名定为txt（纯文本文件）,并用unity的TextAsset列表负责记录所有脚本文件。建议列表中给每个脚本搭配一个string类型的ID，这样凭此ID即可加载正确的lua脚本；另外在LuaState类中新增一个String类型的public成员，赋值为该ID。这样一旦某个Lua脚本在运行时报错，可根据输出的ID值判断是哪个Lua脚本有错误。 4.ulua框架在Unity中的使用（SimpleFramework_UGUI解读） 框架启动 GlobalGenerator:初始化游戏环境,包括添加AppView,启动pureMVC框架，添加各种Manager GameManager中对资源进行更新处理 资源初始化过程 OnResourceInited 加载网络、游戏管理器的Lua脚本 调用GameManager.lua里的LuaScriptPanel方法（CallMethod通过LuaScriptMgr.cs的CallLuaFunction()将控制权移交给GameManager.lua） 创建Lua面板（Message、Prompt） 调用方法OnInitOK表示初始化成功 ulua框架的执行顺序： 每个UI Panel对应View下的lua代码，用来获取一些需要交互的属性 每个UIprefab通过Controller进行控制，包括其实例化以及组件的一些行为，比如OnCreate事件 热更新案例：UI面板更新创建开发UI界面 设计UI Panel 将UI panel做成prefab,进行打包（注意后缀一定为.assetbundle） 将UI panel所用到的所有UI资源进行打包（图片、字体等），最好分类打包 点击Game-Build XXX Resources(XXX 代表想要发布到的平台) 创建Global Generator（空Object上挂Global Generator脚本） 重写Logic文件夹中的GameManager.lua脚本123456789101112131415161718192021require "Common/define" --引入AppConst,NetManager的定义require "Controller/BottomCtrl" --以下引入对各子面板的控制器require "Controller/SettingsCtrl"require "Controller/DialogCtrl"GameManager = &#123;&#125;function GameManager.LuaScriptPanel() return 'Bottom','Settings','Dialog'; --Prefab中除掉“Panel”后的名字endfunction GameManager.OnInitOK() --加载网络 AppConst.SocketPort = 2012; --设置套接字端口号 AppConst.SocketAddress = "127.0.0.1"; --设置套接字IP地址，这里默认从主机下载资源 NetManager:SendConnect(); --建立连接 BottomCtrl.Awake(); SettingsCtrl.Awake(); DialogCtrl.Awake();end View文件夹下创建子面板的lua脚本（以BottomPanel.lua为例，其他同理）1234567891011121314151617181920BottomPanel = &#123;&#125;local this = BottomPanellocal gameObjectlocal transformfunction BottomPanel.Awake(obj) --对局部变量进行赋值 gameObject = obj; transform = gameObject.transform this.InitPanel();--初始化面板endfunction BottomPanel.InitPanel() --给面板中的三个Button赋值 this.buttonSettings = transform:FindChild("ButtonSetting").gameObject; this.buttonPeople = transform:FindChild("ButtonPeople").gameObject; this.buttonDialog = transform:FindChild("ButtonDialog").gameObject;end [可选]给SettingPanel下的BG添加动画：由小变大动画、隐藏动画、激活动画 重写SettingPanel.lua脚本获取UI中的组件123456789101112131415161718SettingsPanel = &#123;&#125;local this = SettingsPanellocal transformlocal gameObjectfunction SettingsPanel.Awake(obj) gameObject = obj; transform = gameObject.transform; this.InitPanel();endfunction SettingsPanel.InitPanel() --获取动画组件及按钮组件 this.anim = transform:FindChild("Bg"):GetComponent("Animator"); this.buttonClose = transform:FindChild("Bg/ButtonClose").gameObject;end 开发Controller控制层下的Lua代码，控制UI控件的产生和事件的监听（以BottomCtrl.lua为例）12345678910111213141516171819202122232425262728293031323334353637383940require "Common/define"BottomCtrl = &#123;&#125;local this = BottomCtrllocal gameObjectlocal transformlocal luafunction BottomCtrl.New() return this;endfunction BottomCtrl.Awake() --调用panel的创建方法创建相应面板，注意面板命名为XXPanel PanelManager:CreatePanel("Bottom",this.OnCreate)endfunction BottomCtrl.OnCreate(obj) gameObject = obj; transform = obj.transform lua = gameObject:GetComponent("LuaBehaviour"); --注册按钮，绑定事件 lua:AddClick(BottomPanel.buttonDialog,this.OnButtonDialogClick); lua:AddClick(BottomPanel.buttonPeople,this.OnButtonPeopleClick); lua:AddClick(BottomPanel.buttonSettings,this.OnButtonSettingsClick);endfunction BottomCtrl.OnButtonDialogClick() DialogCtrl.Show();endfunction BottomCtrl.OnButtonPeopleClick() endfunction BottomCtrl.OnButtonSettingsClick() SettingsCtrl.Show();end 发布到手机上，启动Server Switch Platform - Android Lua-Clear Wrap Files Lua-Gen Wrap Files Game-Build Android Resources 修改AppConst.cs里的UpdateMode=true,DebugMode=false,WebUrl=局域网地址（有服务器的话就是服务器地址,这里假设用uLua自带服务器运行） 打开Server.sln-HttpServer.cs，修改host,重新生成工程 运行ulua文件夹下Server/Server/bin/Debug/SuperSocket.SocketService.exe（以管理员权限运行），选择r运行服务器 进行Lua代码的更新 Build &amp; run,手机连电脑，将程序发布到手机 更改Lua代码 重新Build Android Resources 手机重新启动该程序 解包完成！更新完成！ 进行UI资源的更新 创建Dialog Panel,打包，新建Panel,Ctrl脚本文件 重新Build Android Resources 手机重新启动软件注意：如果电脑防火墙没关，手机是没有权限访问电脑的，就会更新失败。。。 Unity3D中的热更新Unity3D的热更新会涉及3个目录。 游戏资源目录：里面包含Unity3D工程中StreamingAssets文件夹下的文件。安装游戏之后，这些文件将会被一字不差地复制到目标机器上的特定文件夹里，不同平台的文件夹不同，如下所示 Mac OS或Windows：Application.dataPath “/StreamingAssets”; IOS： Application.dataPath “/Raw”; Android：jar:file://“ Application.dataPath “!/assets/“; 数据目录：由于“游戏资源目录”在Android和IOS上是只读的，不能把网上的下载的资源放到里面，所以需要建立一个“数据目录”，该目录可读可写。第一次开启游戏后，程序将“游戏资源目录”的内容复制到“数据目录中”（这个步骤只会执行一次，下次再打开游戏就不复制了）。游戏过程中的资源加载，都是从“数据目录”中获取、解包。不同平台下，“数据目录”的地址也不同，LuaFramework的定义如下： Android或IOS：Application.persistentDataPath “/LuaFramework” Mac OS或Windows：c:/LuaFramework/ 调试模式下：Application.dataPath “/StreamingAssets/“ 注：”LuaFramework”和”StreamingAssets”由配置决定，这里取默认值 网络资源地址：存放游戏资源的网址，游戏开启后，程序会从网络资源地址下载一些更新的文件到数据目录。 这些目录包含着不同版本的资源文件，以及用于版本控制的files.txt。Files.txt里面存放着资源文件的名称和md5码。程序会先下载“网络资源地址”上的files.txt，然后与“数据目录”中文件的md5码做比较，更新有变化的文件。 常见问题 &amp;&amp; 注意事项 运行 LuaStudio 时，请使用Administrator管理员权限！ Lua需要统一的UTF-8编码，有时候Lua脚本无故编译出错请检查编码问题！ 若运行到真机，记得一定要设置Const.DebugMode=false 【该点摘录自云风博客】更新时要保护后内存中的非代码数据。这个时候，对 local 变量的使用务必小心。因为 local 变量总会被作为 upvalue 绑定在 closure 里。我们的代码经常会依赖这些 local 变量。在更新后，许多保存数据用的 local 变量会生成新的一份。这很可能丢失重要数据。而因为这个问题回避使用 local 也是不合适的。要知道 local 和 global 变量的性能可不只差上一点半点。我采用的方法是，把数据记录在专用的全局表下，并用 local 去引用它。初始化这些数据的时候，首先应该检查他们是否被初始化过了。这样来保证数据不被更新过程重置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unity中脚本的生命周期详解]]></title>
      <url>%2F2017%2F04%2F20%2FUnity%E4%B8%AD%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[关于脚本的生命周期你都知道多少？ 写在前面 在Unity项目中，经常会使用到Start、Update、Awake、OnEnable、LateUpdate、OnDisable、OnDestroy、OnGUI、FixedUpdate方法，然而，它们的生命周期你都清楚么？看上去好像无关紧要的东西往往会在不经意间给你挖了一个坑…曾经被坑过的我如是说：) Unity脚本的生命周期 先上一张图: 接下来将逐个讲解… Awake Awake在MonoBehavior创建后就立刻调用，此后每当脚本被加载时调用一次Awake,即使脚本没有被激活；在脚本实例的整个生命周期中，Awake函数仅执行一次；值得注意的一点是，Awake函数的执行与否与脚本实例的状态（启用或禁用）并没有关系，而是与脚本实例所绑定的游戏对象的开关状态有关。如果游戏对象（即gameObject）的初始状态为关闭状态，那么运行程序，Awake函数不会执行；如果游戏对象的初始状态为开启状态，那么Awake函数会执行；如果重新加载场景，那么场景内Awake函数的执行情况重新遵循上述两点。 Start Start()将在MonoBehavior创建后在该帧Update()第一次执行前被调用；只会在第一次调用Update之前调用一次；Start()函数只在脚本实例被启用时才会执行；Start函数总是在Awake函数之后执行。如果游戏对象开启了，对象上绑定的脚本实例被禁用了，那么Start函数不会执行。这是Start函数的特点，只有在脚本实例被启用且是首次启用时它才会执行。如果是已经开启过的脚本实例被关闭后再次开启，那么Start函数不会再次执行。 注：一般开发中都是在Awake函数中获取游戏对象或者脚本实例的信息，然后在Start函数中进行一些获取之后的初始化设置。 Update &amp;&amp; LateUpdate &amp;&amp; FixedUpdate 当MonoBehaviour启用时,其Update 和 LateUpdate在每一帧被调用；Update每帧调用一次（每秒60帧不会卡），一般用于处理画面逻辑; LateUpate一般用于刷新其他逻辑，注意LateUpdate是晚于所有Update执行的。一般类似相机跟随的代码会放到lateupdate里面去执行。举个栗子，一个宿舍4个人，每个人的起床在update中执行，出发在某个人中的lateupdate执行，这样就可以保证每个人都起床了才会出发 而FixedUpdate会在每个固定的物理时间片被调用一次.不会受到图像刷新帧速率的影响。这是放置游戏基本物理行为代码的地方。在Update之后调用。 OnEnable &amp;&amp; OnDisable &amp;&amp; OnDestory OnEnable:在每次激活脚本时调用OnEnable; OnDisable:取消激活状态后调用 OnDestroy：被销毁时调用一次 注：Awake、OnEnable、Start,都是游戏开始运行前就调用的方法。 GameObject的Activity为true，脚本的enable为true时，其先后顺序为：Awake、OnEnable、Start； GameObject的Activity为true，脚本的enable为false时,只运行Awake； GameObject的Activity为false时，以上都不调用，OnDisable()被调用； OnGUI 这个函数会每帧调用好几次（每个事件一次），GUI显示函数只能在OnGui中调用 Reset Reset是在用户点击检视面板的Reset按钮或者首次添加该组件时被调用.此函数只在编辑模式下被调用.Reset最常用于在检视面板中给定一个最常用的默认值.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo静态博客搭建+个人定制]]></title>
      <url>%2F2017%2F03%2F24%2FHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2B%E4%B8%AA%E4%BA%BA%E5%AE%9A%E5%88%B6%2F</url>
      <content type="text"><![CDATA[打造高逼格的个人博客 写在前面 很早以前就想写这样一篇了，因为各种原因耽搁到现在（逃）…网上关于Hexo的教程其实已经有挺多了，但是很多都是一笔带过。这篇博客除了Hexo博客的搭建过程，还有一些我加进去的个人定制模块，以及博客如何被搜索引擎（百度、谷歌）收录、如何进行SEO优化等等，以及在这过程中遇到的数不胜数的坑。虽然时隔一个月，有些搭建过程遇到的问题记不太清了orz…但是有什么问题还是可以问我的，我尽量解答=3=最后！！！【超长文预警】！！！建议可以先看目录选择感兴趣的部分orz Hexo简介 相信点进来看的都是对 Hexo 已经有了一定了解的吧~简而言之，Hexo 是一个基于 Node.js 的静态博客程序，可以方便的生成静态网页托管在github和Heroku上。其作者是来自台湾的tommy351大神。Hexo 因其界面简洁、美观且对各类人群（不只是程序猿）友好而广受欢迎，声望不亚于大名鼎鼎的WordPress。这也是我放弃 WordPress 改投 Hexo 的原因=。=放一张 Hexo NexT 主题的照片（是不是很好看hhh） 基础配置篇【注：本文中使用的 Hexo 版本为3.22，部分配置与2.x可能有所出入】 1.安装 &amp; 搭建 安装Git：安装后，注册 Github 账号，配置 SSH（具体见下一步）,打开 Git Bash,接下来的命令均在Git Bash中执行 安装Node.js 安装 Hexo : $npm install -g hexo 安装依赖包： $npm install 新建博客文件夹：cd到该文件夹，执行$hexo init 新建Github仓库：仓库名必须为你的Github名.github.io，要不然就不能使用Github Pages服务了。。。 2.配置 SSH 关于什么是 SSH，请自行百度（我懒..）这里直接讲一下配置步骤。 本地生成公钥私钥 $ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 添加公钥到 Github 根据上一步的提示，找到公钥文件（默认为id_rsa.pub），用记事本打开，全选并复制。 登录 Github，右上角 头像 -&gt; Settings —&gt; SSH keys —&gt; Add SSH key。把公钥粘贴到key中，填好title并点击 Add key。 git bash中输入命令$ssh -T git@github.com，选yes，等待片刻可看到成功提示。 3. NexT主题下载 NexT 主题是由 iissnan 大神所制作的一款简洁美观不失逼格的主题。下载方法有以下两种： 进入博客根目录/themes/, 执行$git clone https://github.com/iissnan/hexo-theme-next.git 直接进入上面的链接，在项目主页download zip文件，然后解压到博客根目录/themes/ 文件夹 4. 发布 使用以下两条命令进行发布，发布成功后可在浏览器中使用你的github名.github.io进入你的博客~12$hexo clean$hexo d -g Hexo日常使用篇1.生成静态页面：1$hexo generate 2.本地预览：12$hexo server//或 hexo s//然后打开浏览器输入localhost:4000可以预览博客效果，用于调试 3. 新建文章12$hexo new post &quot;title&quot;//新文章位置：/source/_posts 4. 新建页面1$hexo new page &quot;title&quot; 5. 部署并生成1$hexo d -g 6. 清除生成的文件和缓存1$hexo clean _config文件配置篇1.整站配置直接贴一下我的配置文件吧【路径：博客根目录/_config.yml】 【友情提示：不要用系统自带记事本打开，容易出现编码不一致问题，最好用 Notepad++ 或 Sublime Text 之类的】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Lemon-XQ # 博客名subtitle: Stay Hungry, Stay Foolish # 副标题description: 银河街角，时光路口 # 站点描述author: Lemon-XQ # 作者名language: zh-Hans # 语言设置timezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://lemonxq.cn # 博客所要绑定的域名，没有则不填root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: # Hexo自带代码高亮插件 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页显示文章数pagination_dir: page# Extensions # 以下为第三方插件设置## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next # 使用的主题，主题配置后面讲search: # 本地搜索插件 path: search.xml field: post format: html limit: 10000feed: # RSS订阅插件 type: atom path: atom.xml limit: 0plugins:baidusitemap: # 百度站点地图 path: baidusitemap.xml# Deployment # 非常重要的部署设置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: # 可选择同时部署到 GitHub 和 coding 或者只部署到 Github github: git@github.com:你的GitHub名/你的GitHub名.github.io.git coding: git@git.coding.net:你的Coding名/你的Coding名.git branch: master 2.Next主题配置一样贴一下我的主题config文件吧，注意和上面的全局config文件区分。【路径：博客根目录/themes/next/_config.yml】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico # 网站logo# Set default keywords (Use a comma to separate)keywords: "Lemon,xq,unity,Hexo" # 网站关键词，有利于SEO优化# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml# Specify the date when the site was setupsince: 2017 # 建站年份# icon between year and author @Footerauthoricon: heart# Footer `powered-by` and `theme-info` copyrightcopyright: true# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: # 菜单栏设置 home: / categories: /categories about: /about archives: /archives tags: /tags #sitemap: /sitemap.xml #commonweal: /404.html# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: # 菜单项图标 enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes # NexT 主题提供三种布局#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal intalic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------#friend linkslinks_title: 友情链接links: # 添加你的友情链接（eg. 慕课网: imooc.com）# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)social: # 添加你的社交账号 GitHub: https://github.com/Lemon-XQ# Social Links Icons# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of the item and value is the name of FontAwsome icon. Key is case-senstive.# When an globe mask icon presenting up means that the item has no mapping icon.social_icons: enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /images/avatar.jpg # 自定义头像# 是否为侧边栏文章的目录自动添加索引# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # 这个改了好像没什么用。。。 # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove# Blogrolls #links_title: Links#links_layout: block#links_layout: inline#links: #Title: http://example.com/# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# 开启后使用 &lt;!-more--&gt; 可以实现点击查看全文效果scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true#开启微信赞赏# Wechat Subscriberwechat_subscriber: enabled: true qcode: http://okwl1c157.bkt.clouddn.com/wechat-qcode.jpg description: 坚持原创技术分享，您的支持将鼓励我继续创作！# ---------------------------------------------------------------# Misc Theme Settings # Misc布局设置# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image: # Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-theme# 设置代码高亮主题highlight_theme: night bright# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# 自从Swiftype要收费后。。。你懂的# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# 多说 你的昵称# Duoshuo ShortNameduoshuo_shortname: lemonxq# Disqus#disqus_shortname:# Hypercomments#hypercomments_id:# Gentie productKey#gentie_productKey:# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share#jiathis:# Warning: JiaThis does not support https.#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ countcnzz_siteid: # CNZZ站长统计功能，开启服务后将siteid添加在此处# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.# 多说评论功能duoshuo_info: ua_enable: true admin_enable: true user_id: # 管理员ID admin_nickname: 博主duoshuo_hotartical: true # 多说 热评文章# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.# 启动页面浏览量功能leancloud_visitors: enable: true app_id: # leancloud 控制台后台获取 app_key: # leancloud 控制台后台获取# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 不蒜子统计功能busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: false site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: false site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: false page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO# 百度推送baidu_push: true# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms" 个人定制模块更改代码块颜色及字体大小 打开\themes\next\source\css\ _variables\base.styl文件 修改$code-background和$code-foreground的值：12345678// Code &amp; Code Blocks// 用``围出的代码块// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 15px # 代码字体大小$code-background = #自定义RGB值$code-foreground = #自定义RGB值$code-border-radius = 4px 实现底栏半透明 打开博客根目录/themes/next/source/css/_common/components/footer/footer,styl文件 在最开始的.footer中修改color值为#99912345678.footer &#123; font-size: 14px; color: #999; img &#123; border: none; &#125; +mobile()&#123; font-size: 13px; &#125;&#125; 添加背景图片 将背景图片命名为background.jpg并放入博客根目录/source/images文件夹中 打开博客根目录/themes/next/source/css/_custom/custom.styl文件 加入如下代码： 123456// Custom styles.body &#123; background-image: url(/images/background.jpg); background-attachment: fixed; background-repeat: no-repeat;&#125; 域名绑定购买域名 一个高逼格的博客怎么能够少了域名呢=。=域名提供商有很多，像godaddy、万网等。如果是学生党的话推荐使用腾讯云“1元云主机+域名”计划。 绑定域名这里以在腾讯云购买的域名为例。 进入腾讯云后台域名管理，点击解析域名 添加DNS记录：【注：腾讯云中DNS记录生效需要十分钟，请耐心等待】 在博客根目录里的source目录中新建CNAME文本文件（不带任何后缀！！！），然后用Notepad++编辑CNAME文件，写入你的域名，保存退出 重新部署一下博客（hexo clean、hexo d -g） 试试能不能通过域名访问到你的博客 百度 &amp; 谷歌收录检测站点是否已被百度 or 谷歌收录的方法： 在百度 or 谷歌搜索框中输入site:你的站点然后回车，如果有结果显示，说明已被收录。 百度收录 让百度收录我的博客真的是经历了很长的一段过程。。。关于提交sitemap、设置推送链接可以看一下这篇文章。事实上按照该博客的做法后，我等了一个星期都没有收录成功（明明谷歌的都收录了orz）。后来，我发现了原因。那就是github禁止了百度爬虫，而我的站点又是托管在github上的，所以百度爬取不到我的网页，自然收录不了，以下是解决方案。 将博客同时部署在github和coding上，coding的服务器在国内，访问速度快，而且最重要的是不禁百度爬虫 打开根目录下_config.yml文件，修改最下面的deploy部分如下 123456deploy: type: git repository: github: git@github.com:你的GitHub名/你的GitHub名.github.io.git coding: git@git.coding.net:你的Coding名/你的Coding名.git branch: master coding上创建一个新项目，建议命名为你的Github名 本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。添加后，在git bash命令输入：ssh -T git@git.coding.net检测公钥是否添加成功 在coding项目主页中点击pages服务，进行如下配置 在DNS Pod中添加两条CNAME记录，如下 重新部署博客，等待一两天后应该就可以在百度里搜索到你的博客啦（虽然目前为止，百度好像也就收录了我的站点首页= =） 小tips：百度主动推送比自动推送等要快的多，因此每写完一篇博客后，建议自己主动推送给百度，方法百度站长平台里有写 小tips之二：在百度站长平台索引量工具定制索引规则为：你的站点/* 可以加快百度爬虫爬取你的博客网站下的子网页并建立索引的速度。谷歌收录让谷歌收录就容易多了，只要提交站点地图然后验证域名所有权就行了，具体的上面那篇文章也很详细地介绍了，这里不再赘述。 SEO优化更改首页标题格式打开\themes\next\layout\index.swig文件，找到这行代码：1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 把它改成：123&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;&#123;% endblock %&#125; 外链生成 这里推荐使用外链工具为你的站点批量生成外链。百度一下“超级外链SEO工具”，输入站点名，然后就让它自动为你生成外链吧~~新站的话建议每天刷两次。 参考资料 Hexo3.1.1静态博客搭建指南 NexT使用文档 Hexo官方文档（中文版）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cent OS下网络配置的详细步骤及一些坑]]></title>
      <url>%2F2017%2F03%2F04%2FCent-OS%E4%B8%8B%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
      <content type="text"><![CDATA[写在前面 本步骤基于cent os 6.5，使用的虚拟机是Virtual Box。最终可实现主机与虚拟机互ping通，虚拟机与外网互ping通。当然，如果是cent os 7.0以上或者虚拟机是VM ware的，可能会有些差异。 虚拟机网络配置 打开主机“网络连接”，可以看到有一块虚拟网卡（VirtualBox Host-Only Network）,双击查看详细信息PS: 虚拟网卡不一定只有一块，具体可在虚拟机全局设定中进行设置，这里我选择了第二块虚拟网卡作为cent os的物理网卡。 记下详细信息中网卡的IP地址（192.168.137.1） 在“网络连接”中右键选择你当前上网所用的网卡（这里我用的是无线网卡），打开属性，在“共享”一栏选择刚才的那块虚拟网卡。PS：这一步非常重要！！！目的是建立虚拟网卡与主机物理网卡的联系，从而达到共享网络的效果（个人理解类似于桥接） 打开VirtualBox的全局设定，进行如下设置： 打开cent os虚拟机的设置，进行如下配置：PS：这里我使用的是Host-Only，实际上使用桥接也可以，使用桥接的话直接桥接到主机物理网卡，无须设置共享Cent OS中网络配置 配置ip地址使用命令 vi /etc/sysconfig/network-scripts/ifcfg-eth0 修改文件内容如下： 配置网关使用命令 vi /etc/sysconfig/network 修改文件内容如下： 配置DNS服务使用命令 vi /etc/resolv.conf 修改文件内容如下： 重启网络服务（service network restart） 一些注意事项 以上步骤理论上可实现虚拟机与主机、虚拟机与外网互ping通，如果只有虚拟机ping不通主机，那么应该是主机的防火墙没有关闭，主机ping不通虚拟机也可能是这个原因。 如果更换网络或者对该虚拟机进行了迁移导致执行ifconfig命令后找不到eth0网卡，则只需执行以下几步： 执行 ifconfig -a 命令查看虚拟机网卡（一般是eth1）地址(即HWaddr) 执行 vi /etc/sysconfig/network-scripts/ifcfg-eth0 修改HWaddr值为虚拟机网卡地址 执行 rm －rf /etc/udev/rules.d/70-persistent-net.rules 删除70-persistent-net.rules文件 重启系统 reboot -h now]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello~]]></title>
      <url>%2F2017%2F02%2F04%2FHello%2F</url>
      <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客:)可以戳这里了解一下我~ 有任何技术上的问题，欢迎一起探讨=。=]]></content>
    </entry>

    
  
  
</search>
